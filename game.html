<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My AI Skill Game with Ollama</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
        }
        #gameArea {
            width: 600px;
            height: 400px;
            border: 2px solid black;
            background: lightgray;
            position: relative;
            overflow: hidden;
        }
        #character {
            width: 50px;
            height: 50px;
            background: blue;
            border-radius: 50%;
            position: absolute;
            top: 175px;
            left: 275px;
        }
        #rangedBall {
            width: 20px;
            height: 20px;
            background: red;
            border-radius: 50%;
            position: absolute;
            display: none;
        }
        #dummy {
            width: 50px;
            height: 50px;
            background: red;
            border-radius: 50%;
            position: absolute;
            top: 175px;
            left: 450px;
            text-align: center;
            line-height: 50px;
            color: white;
        }
        #skillInput {
            margin-top: 10px;
            width: 300px;
        }
        #skillList {
            margin-top: 10px;
            width: 300px;
            position: relative;
        }
        .skill {
            margin-bottom: 10px;
            position: relative;
            background: rgba(0, 0, 0, 0.05);
            padding: 2px;
            border-radius: 5px;
        }
        .skill button {
            width: calc(100%);
            padding: 15px;
            margin-bottom: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .skill-shortcut {
            background: rgba(0, 0, 0, 0.2);
            padding: 3px 8px;
            border-radius: 3px;
            margin-left: 8px;
            font-size: 0.9em;
            cursor: pointer;
            transition: background 0.2s;
        }
        .skill-shortcut:hover {
            background: rgba(0, 0, 0, 0.4);
        }
        .skill-shortcut.listening {
            animation: pulse 1s infinite;
            background: rgba(0, 255, 0, 0.2);
        }
        .skill-description {
            font-size: 12px;
            white-space: pre-line;
            line-height: 1.4;
            padding: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.9);
            display: none;
        }
        .skill:hover .skill-description {
            display: block;
            position: absolute;
            left: 100%;
            top: 0;
            width: 300px;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-left: 10px;
        }
        .element-tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            color: white;
            font-weight: bold;
            margin-right: 5px;
        }
        .technical-details {
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }
        #statsPanel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 2px 0;
        }
        .stat-button {
            width: 20px;
            height: 20px;
            margin-left: 5px;
            display: none;
        }
        #expBar {
            width: 100px;
            height: 10px;
            background: #333;
            margin-top: 5px;
        }
        #expFill {
            width: 0%;
            height: 100%;
            background: #00ff00;
        }
        #hpSpBar {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
        .bar {
            width: 100px;
            height: 10px;
            margin: 5px 0;
        }
        #hpBar {
            background: #333;
        }
        #hpFill {
            width: 100%;
            height: 100%;
            background: #ff0000;
        }
        #spBar {
            background: #333;
        }
        #spFill {
            width: 100%;
            height: 100%;
            background: #0000ff;
        }
        .combat-text {
            position: absolute;
            font-weight: bold;
            animation: floatUp 1.5s ease-out forwards;
            text-shadow: 0px 0px 3px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 1000;
        }
        .skill-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 170%;
            gap: 8px;
        }
        .remove-skill {
            background: none;
            color: #ff4444;
            border: none;
            padding: 0;
            cursor: pointer;
            font-size: 40px;
            font-weight: bold;
            width: fit-content;
            height: fit-content;
            min-width: 0;
            display: inline;
        }
        .remove-skill:hover {
            color: #ff0000;
        }
        .potion {
            width: 20px;
            height: 20px;
            position: absolute;
            border-radius: 50%;
            cursor: pointer;
            animation: pulse 1s infinite;
            z-index: 100;
        }
        .hp-potion {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ff0000);
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        .sp-potion {
            background: radial-gradient(circle at 30% 30%, #6b88ff, #0000ff);
            box-shadow: 0 0 10px rgba(0, 0, 255, 0.5);
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-30px);
            }
        }

        #dummy[data-status]::before {
            content: attr(data-status);
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
        }
        .skill-button {
            position: relative;
        }
        
        .key-bind {
            position: absolute;
            top: -15px;
            right: -5px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            border: 1px solid #666;
        }

        .listening-for-key {
            animation: pulse 1s infinite;
            border: 2px solid #00ff00;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(0, 255, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0); }
        }

        .rebind-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            border: 1px solid #666;
            display: none;
        }
        .shortcut-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 1000;
            border: 1px solid #666;
            pointer-events: none;
            display: none;
        }

        .warning-message {
            position: fixed;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 1000;
            border: 1px solid #ff6666;
            animation: fadeOut 2s forwards;
            pointer-events: none;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        .ai-loading {
            display: none;
            margin-left: 10px;
            color: #666;
            font-style: italic;
        }

        .ai-error {
            color: #ff4444;
            margin-top: 5px;
            padding: 8px;
            border-radius: 4px;
            background: rgba(255, 0, 0, 0.1);
            display: none;
        }

        .floating-text {
            position: absolute;
            animation: floatUp 2s forwards;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .level-up {
            color: #FFD700;
            font-size: 24px;
            text-shadow: 
                0 0 5px #FFA500,
                0 0 10px #FF8C00,
                0 0 15px #FF7F50;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="gameArea">
        <div id="statsPanel">
            <div>Level: <span id="levelDisplay">1</span></div>
            <div>Stat Points: <span id="statPoints">0</span></div>
            <div id="expBar"><div id="expFill"></div></div>
            <div class="stat-row">
                STR: <span id="strStat">1</span><button class="stat-button" onclick="addStat('str')">+</button>
            </div>
            <div class="stat-row">
                AGI: <span id="agiStat">1</span><button class="stat-button" onclick="addStat('agi')">+</button>
            </div>
            <div class="stat-row">
                DEX: <span id="dexStat">1</span><button class="stat-button" onclick="addStat('dex')">+</button>
            </div>
            <div class="stat-row">
                INT: <span id="intStat">1</span><button class="stat-button" onclick="addStat('int')">+</button>
            </div>
            <div class="stat-row">
                VIT: <span id="vitStat">1</span><button class="stat-button" onclick="addStat('vit')">+</button>
            </div>
            <div class="stat-row">
                LUK: <span id="lukStat">1</span><button class="stat-button" onclick="addStat('luk')">+</button>
            </div>
        </div>
        <div id="hpSpBar">
            <div>HP: <span id="hpDisplay">100/100</span></div>
            <div class="bar" id="hpBar"><div id="hpFill"></div></div>
            <div>SP: <span id="spDisplay">50/50</span></div>
            <div class="bar" id="spBar"><div id="spFill"></div></div>
        </div>
        <div id="character"></div>
        <div id="rangedBall"></div>
        <div id="dummy">100</div>
    </div>
    <input type="text" id="skillInput" placeholder="Type a skill (e.g., 'shoot a fire ball')">
    <button onclick="createSkill()">Summon Skill</button>
    <button onclick="resetDummy()">Reset Dummy</button>
    <div id="skillList"></div>

    <script>
        const character = document.getElementById('character');
        const rangedBall = document.getElementById('rangedBall');
        const dummy = document.getElementById('dummy');
        const skillInput = document.getElementById('skillInput');
        const skillList = document.getElementById('skillList');
        let charX = 275;
        let charY = 175;
        let dummyHealth = 100;
        let skills = [];

        // RPG System Variables
        let playerStats = {
            level: 1,
            exp: 0,
            statPoints: 0,
            str: 1,
            agi: 1,
            dex: 1,
            int: 1,
            vit: 1,
            luk: 1,
            hp: 100,
            maxHp: 100,
            sp: 50,
            maxSp: 50,
            skillCooldown: false,
            lastSpRegen: Date.now() // Add timestamp for SP regeneration
        };

        // Element system
        const elements = {
            neutral: { 
                name: "Neutral", 
                color: "gray", 
                strongAgainst: [], 
                weakAgainst: [],
                gradient: "linear-gradient(45deg, #808080, #A0A0A0)",
                textColor: "#FFFFFF",
                particleColor: "#C0C0C0",
                description: "Basic non-elemental force"
            },
            fire: { 
                name: "Fire", 
                color: "orange", 
                strongAgainst: ["earth", "undead"], 
                weakAgainst: ["water", "poison"],
                gradient: "linear-gradient(45deg, #FF4500, #FF8C00)",
                textColor: "#FFFFFF",
                particleColor: "#FFD700",
                description: "Burning flames that consume all"
            },
            water: { 
                name: "Water", 
                color: "blue", 
                strongAgainst: ["fire"], 
                weakAgainst: ["wind", "earth"],
                gradient: "linear-gradient(45deg, #00BFFF, #1E90FF)",
                textColor: "#FFFFFF",
                particleColor: "#87CEEB",
                description: "Flowing water that extinguishes flames"
            },
            wind: { 
                name: "Wind", 
                color: "lightgreen", 
                strongAgainst: ["water"], 
                weakAgainst: ["earth", "poison"],
                gradient: "linear-gradient(45deg, #90EE90, #98FB98)",
                textColor: "#000000",
                particleColor: "#F0FFF0",
                description: "Swift winds that cut through water"
            },
            earth: { 
                name: "Earth", 
                color: "brown", 
                strongAgainst: ["wind"], 
                weakAgainst: ["fire"],
                gradient: "linear-gradient(45deg, #8B4513, #A0522D)",
                textColor: "#FFFFFF",
                particleColor: "#DEB887",
                description: "Solid earth that grounds the wind"
            },
            poison: { 
                name: "Poison", 
                color: "purple", 
                strongAgainst: ["neutral"], 
                weakAgainst: ["wind"],
                gradient: "linear-gradient(45deg, #800080, #9400D3)",
                textColor: "#FFFFFF",
                particleColor: "#DA70D6",
                description: "Toxic essence that corrupts life"
            },
            holy: { 
                name: "Holy", 
                color: "yellow", 
                strongAgainst: ["undead", "shadow"], 
                weakAgainst: ["shadow"],
                gradient: "linear-gradient(45deg, #FFD700, #FFFF00)",
                textColor: "#000000",
                particleColor: "#FFFACD",
                description: "Divine light that banishes darkness"
            },
            shadow: { 
                name: "Shadow", 
                color: "darkviolet", 
                strongAgainst: ["holy"], 
                weakAgainst: ["holy"],
                gradient: "linear-gradient(45deg, #483D8B, #4B0082)",
                textColor: "#FFFFFF",
                particleColor: "#9370DB",
                description: "Dark forces that corrupt light"
            },
            undead: { 
                name: "Undead", 
                color: "darkgray", 
                strongAgainst: ["neutral"], 
                weakAgainst: ["fire", "holy"],
                gradient: "linear-gradient(45deg, #696969, #808080)",
                textColor: "#FFFFFF",
                particleColor: "#A9A9A9",
                description: "Unholy power that defies life"
            }
        };

        let dummyElement = "neutral";

        // Add element selector for dummy
        function addElementSelector() {
            const selector = document.createElement('select');
            selector.id = 'dummyElement';
            selector.style.marginLeft = '10px';
            for (const [key, value] of Object.entries(elements)) {
                const option = document.createElement('option');
                option.value = key;
                option.text = value.name;
                selector.appendChild(option);
            }
            selector.onchange = (e) => {
                dummyElement = e.target.value;
                dummy.style.background = elements[dummyElement].color;
            };
            const resetButton = document.querySelector('button[onclick="resetDummy()"]');
            resetButton.parentNode.insertBefore(selector, resetButton.nextSibling);
        }

        // Calculate elemental damage modifier
        function calculateElementalModifier(attackElement, targetElement) {
            // Same element penalty (25% reduction)
            if (attackElement === targetElement) {
                return 0.75;
            }

            // Element advantages based on Ragnarok Online system
            const elementAdvantages = {
                fire: { water: 0.5, earth: 1.5, undead: 1.5, poison: 0.5 },
                water: { fire: 1.5, wind: 0.5, earth: 0.5 },
                wind: { water: 1.5, earth: 0.5, poison: 0.5 },
                earth: { wind: 1.5, fire: 0.5, poison: 0.5 },
                poison: { earth: 1.5, wind: 1.5, fire: 1.5 },
                holy: { undead: 2.0, shadow: 1.25, demon: 1.5 },
                shadow: { holy: 1.25, ghost: 1.5 },
                undead: { fire: 0.5, poison: 0.5, holy: 0.5 },
                neutral: {} // Neutral has no advantages or disadvantages
            };

            // Check if there's an advantage defined
            if (elementAdvantages[attackElement]?.[targetElement]) {
                return elementAdvantages[attackElement][targetElement];
            }

            // Default case - no special relationship
            return 1.0;
        }

        // Experience needed for each level (Ragnarok Online-like progression)
        function expForLevel(level) {
            if (level <= 1) return 0;
            return Math.floor(Math.pow(level - 1, 3) + 100);
        }

        // Update all displays
        function updateDisplays() {
            document.getElementById('levelDisplay').textContent = playerStats.level;
            document.getElementById('statPoints').textContent = playerStats.statPoints;
            document.getElementById('strStat').textContent = playerStats.str;
            document.getElementById('agiStat').textContent = playerStats.agi;
            document.getElementById('dexStat').textContent = playerStats.dex;
            document.getElementById('intStat').textContent = playerStats.int;
            document.getElementById('vitStat').textContent = playerStats.vit;
            document.getElementById('lukStat').textContent = playerStats.luk;
            
            // Update HP/SP displays with SP rounded to 3 decimal places
            document.getElementById('hpDisplay').textContent = `${playerStats.hp}/${playerStats.maxHp}`;
            document.getElementById('spDisplay').textContent = `${playerStats.sp.toFixed(3)}/${playerStats.maxSp}`;
            document.getElementById('hpFill').style.width = `${(playerStats.hp / playerStats.maxHp) * 100}%`;
            document.getElementById('spFill').style.width = `${(playerStats.sp / playerStats.maxSp) * 100}%`;
            
            // Update exp bar
            const expNeeded = expForLevel(playerStats.level + 1) - expForLevel(playerStats.level);
            const currentExp = playerStats.exp - expForLevel(playerStats.level);
            const expPercentage = (currentExp / expNeeded) * 100;
            document.getElementById('expFill').style.width = `${expPercentage}%`;

            // Show/hide stat buttons
            const buttons = document.getElementsByClassName('stat-button');
            for (let button of buttons) {
                button.style.display = playerStats.statPoints > 0 ? 'inline' : 'none';
            }
        }

        // Add stat point
        function addStat(stat) {
            if (playerStats.statPoints > 0) {
                playerStats[stat]++;
                playerStats.statPoints--;
                
                // Update derived stats
                if (stat === 'vit') {
                    playerStats.maxHp = 100 + (playerStats.vit * 20);
                    playerStats.hp = playerStats.maxHp;
                }
                if (stat === 'int') {
                    playerStats.maxSp = 50 + (playerStats.int * 10);
                    playerStats.sp = playerStats.maxSp;
                }
                
                updateDisplays();
            }
        }

        // Gain experience and handle level up
        function gainExp(amount) {
            playerStats.exp += amount;
            while (playerStats.exp >= expForLevel(playerStats.level + 1)) {
                playerStats.level++;
                playerStats.statPoints += 3; // 3 stat points per level
                // Restore HP/SP on level up
                playerStats.hp = playerStats.maxHp;
                playerStats.sp = playerStats.maxSp;

                // Show floating level up text
                const levelUpText = document.createElement('div');
                levelUpText.className = 'floating-text level-up';
                levelUpText.textContent = `Level Up! ${playerStats.level}`;
                levelUpText.style.position = 'absolute';
                levelUpText.style.left = `${character.offsetLeft + character.offsetWidth / 2}px`;
                levelUpText.style.top = `${character.offsetTop - 20}px`;
                document.getElementById('gameArea').appendChild(levelUpText);

                // Remove the text after animation
                setTimeout(() => {
                    levelUpText.remove();
                }, 2000);
            }
            updateDisplays();
        }

        // Add status effects system
        const statusEffects = {
            burn: {
                name: 'Burn',
                duration: 5000, // 5 seconds
                tickInterval: 500, // damage every 0.5 seconds
                damagePerTick: 5,
                color: '#ff4444',
                particle: 'ðŸ”¥',
                chance: 0.35, // 35% chance to apply burn
                damageAmplifier: 1.5 // 50% more damage from fire attacks when burned
            },
            poison: {
                name: 'Poison',
                duration: 8000, // 8 seconds
                tickInterval: 1000, // damage every 1 second
                damagePerTick: 3,
                color: '#8b008b',
                particle: 'â˜ ï¸',
                chance: 0.4, // 40% chance to apply poison
                speedReduction: 0.5 // 50% movement speed reduction
            },
            freeze: {
                name: 'Freeze',
                duration: 3000, // 3 seconds
                color: '#87CEEB',
                particle: 'â„ï¸'
            }
        };

        let activeStatusEffects = [];
        let isTargetFrozen = false;
        let baseMovementSpeed = 5; // Store the base movement speed

        function applyStatusEffect(type, element) {
            // Clear existing status of the same type
            activeStatusEffects = activeStatusEffects.filter(effect => effect.type !== type);
            
            if (type === 'burn' && element === 'fire') {
                // Check burn chance
                if (Math.random() < statusEffects.burn.chance) {
                    const burnEffect = {
                        type: 'burn',
                        endTime: Date.now() + statusEffects.burn.duration,
                        lastTickTime: Date.now()
                    };
                    activeStatusEffects.push(burnEffect);
                    showStatusEffect('burn');
                }
            } else if (type === 'poison' && element === 'poison') {
                // Check poison chance
                if (Math.random() < statusEffects.poison.chance) {
                    const poisonEffect = {
                        type: 'poison',
                        endTime: Date.now() + statusEffects.poison.duration,
                        lastTickTime: Date.now()
                    };
                    activeStatusEffects.push(poisonEffect);
                    showStatusEffect('poison');
                    // Apply movement speed reduction
                    moveSpeed = baseMovementSpeed * (1 - statusEffects.poison.speedReduction);
                }
            } else if (type === 'freeze' && element === 'water') {
                // 30% chance to freeze
                if (Math.random() < 0.3) {
                    const freezeEffect = {
                        type: 'freeze',
                        endTime: Date.now() + statusEffects.freeze.duration
                    };
                    activeStatusEffects.push(freezeEffect);
                    isTargetFrozen = true;
                    showStatusEffect('freeze');
                    
                    // Unfreeze after duration
                    setTimeout(() => {
                        isTargetFrozen = false;
                        activeStatusEffects = activeStatusEffects.filter(effect => effect.type !== 'freeze');
                        updateDummyAppearance();
                    }, statusEffects.freeze.duration);
                }
            }
        }

        function showStatusEffect(type) {
            const effect = statusEffects[type];
            const statusText = document.createElement('div');
            statusText.className = 'combat-text';
            statusText.style.position = 'absolute';
            statusText.style.left = '470px';
            statusText.style.top = '130px';
            statusText.style.color = effect.color;
            statusText.style.fontSize = '24px';
            statusText.textContent = effect.particle + ' ' + effect.name;
            document.getElementById('gameArea').appendChild(statusText);
            setTimeout(() => statusText.remove(), 1500);
        }

        // Update dummy appearance based on status
        function updateDummyAppearance() {
            let particles = '';
            for (const effect of activeStatusEffects) {
                particles += statusEffects[effect.type].particle;
            }
            if (particles) {
                dummy.setAttribute('data-status', particles);
                } else {
                dummy.removeAttribute('data-status');
            }

            // Visual effect for frozen state
            if (isTargetFrozen) {
                dummy.style.filter = 'brightness(1.5) saturate(2) hue-rotate(180deg)';
            } else {
                dummy.style.filter = '';
            }
        }

        // Process status effects
        setInterval(() => {
            const now = Date.now();
            let statusChanged = false;

            // Don't process status effects if dummy is already dead
            if (dummyHealth <= 0) {
                activeStatusEffects = [];
                updateDummyAppearance();
                return;
            }

            activeStatusEffects = activeStatusEffects.filter(effect => {
                if (effect.endTime <= now) {
                    statusChanged = true;
                    return false;
                }

                if (effect.type === 'burn' && now - effect.lastTickTime >= statusEffects.burn.tickInterval) {
                    dummyHealth = Math.max(0, dummyHealth - statusEffects.burn.damagePerTick);
                    effect.lastTickTime = now;
                    
                    // Only show burn damage if dummy is still alive
                    if (dummyHealth > 0) {
                        const burnDamage = document.createElement('div');
                        burnDamage.className = 'combat-text';
                        burnDamage.style.position = 'absolute';
                        burnDamage.style.left = '470px';
                        burnDamage.style.top = '150px';
                        burnDamage.style.color = statusEffects.burn.color;
                        burnDamage.textContent = statusEffects.burn.damagePerTick;
                        document.getElementById('gameArea').appendChild(burnDamage);
                        setTimeout(() => burnDamage.remove(), 1000);
                    }
                }

                if (effect.type === 'poison' && now - effect.lastTickTime >= statusEffects.poison.tickInterval) {
                    dummyHealth = Math.max(0, dummyHealth - statusEffects.poison.damagePerTick);
                    effect.lastTickTime = now;
                    
                    // Only show poison damage if dummy is still alive
                    if (dummyHealth > 0) {
                        const poisonDamage = document.createElement('div');
                        poisonDamage.className = 'combat-text';
                        poisonDamage.style.position = 'absolute';
                        poisonDamage.style.left = '470px';
                        poisonDamage.style.top = '150px';
                        poisonDamage.style.color = statusEffects.poison.color;
                        poisonDamage.textContent = statusEffects.poison.damagePerTick;
                        document.getElementById('gameArea').appendChild(poisonDamage);
                        setTimeout(() => poisonDamage.remove(), 1000);
                    }
                }

                // Check if dummy died from DoT damage
                if (dummyHealth <= 0) {
                    dummyHealth = 0;
                    gainExp(50);
                    activeStatusEffects = []; // Clear all status effects
                    statusChanged = true;
                    return false;
                }

                dummy.textContent = dummyHealth;
                return dummyHealth > 0; // Only keep effect if dummy is still alive
            });

            if (statusChanged) {
                updateDummyAppearance();
            }
        }, 100);

        // Add dodge system
        let isDodging = false;
        let dodgeEndTime = 0;
        const TELEPORT_DISTANCE = 100; // Distance in pixels for teleport

        // Add dodge effect to character
        function applyDodgeEffect(isTeleport = false) {
            if (isTeleport) {
                character.style.opacity = '0.3';
                character.style.filter = 'blur(4px) brightness(1.5)';
                character.style.transition = 'all 0.2s ease-out';
            } else {
                character.style.opacity = '0.5';
                character.style.filter = 'blur(2px)';
            }
            character.style.animation = 'none';
            isDodging = true;
        }

        // Remove dodge effect
        function removeDodgeEffect() {
            character.style.opacity = '1';
            character.style.filter = 'none';
            character.style.transition = '';
            isDodging = false;
        }

        // Handle teleport dodge in specific direction
        function handleTeleportDodge() {
            let dx = 0;
            let dy = 0;

            if (pressedKeys.has('w')) dy -= 1;
            if (pressedKeys.has('s')) dy += 1;
            if (pressedKeys.has('a')) dx -= 1;
            if (pressedKeys.has('d')) dx += 1;

            // If no direction pressed, teleport forward (right)
            if (dx === 0 && dy === 0) {
                dx = 1;
            }

            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }

            // Calculate new position
            const newX = Math.max(0, Math.min(550, charX + dx * TELEPORT_DISTANCE));
            const newY = Math.max(0, Math.min(350, charY + dy * TELEPORT_DISTANCE));

            // Create afterimage effect
            const afterimage = document.createElement('div');
            afterimage.style.position = 'absolute';
            afterimage.style.width = '50px';
            afterimage.style.height = '50px';
            afterimage.style.background = 'rgba(0, 0, 255, 0.3)';
            afterimage.style.borderRadius = '50%';
            afterimage.style.left = charX + 'px';
            afterimage.style.top = charY + 'px';
            afterimage.style.animation = 'fadeOut 0.5s forwards';
            document.getElementById('gameArea').appendChild(afterimage);

            // Add fadeOut animation if it doesn't exist
            if (!document.querySelector('#teleportStyle')) {
                const style = document.createElement('style');
                style.id = 'teleportStyle';
                style.textContent = `
                    @keyframes fadeOut {
                        from { opacity: 0.3; transform: scale(1); }
                        to { opacity: 0; transform: scale(0.5); }
                    }
                `;
                document.head.appendChild(style);
            }

            // Teleport to new position
            charX = newX;
            charY = newY;
            character.style.left = charX + 'px';
            character.style.top = charY + 'px';

            // Remove afterimage after animation
            setTimeout(() => afterimage.remove(), 500);
        }

        // Modify createSkillEffect to handle teleport dodge skills
        function createSkillEffect(type, color, damage, spCost, element, skillName, isDodgeSkill = false, cooldownMs = 1000) {
                return () => {
                if (playerStats.skillCooldown || playerStats.sp < spCost) {
                    const errorText = document.createElement('div');
                    errorText.className = 'combat-text';
                    errorText.style.left = (charX + 25) + 'px';
                    errorText.style.top = (charY - 20) + 'px';
                    errorText.style.color = '#ff4444';
                    errorText.style.fontSize = '14px';
                    errorText.textContent = playerStats.skillCooldown ? "Cooldown!" : "Not enough SP!";
                    document.getElementById('gameArea').appendChild(errorText);
                    setTimeout(() => errorText.remove(), 1500);
                    return;
                }

                // Handle dodge skills
                if (isDodgeSkill) {
                    const dodgeDuration = 1000; // 1 second of dodge
                    const isTeleport = skillName.toLowerCase().includes('teleport') || 
                                     skillName.toLowerCase().includes('blink');
                    
                    applyDodgeEffect(isTeleport);
                    dodgeEndTime = Date.now() + dodgeDuration;

                    if (isTeleport) {
                        handleTeleportDodge();
                    }

                    // Show dodge activation text
                    const dodgeText = document.createElement('div');
                    dodgeText.className = 'combat-text';
                    dodgeText.style.position = 'absolute';
                    dodgeText.style.left = (charX + 25) + 'px';
                    dodgeText.style.top = (charY - 40) + 'px';
                    dodgeText.style.color = '#ffffff';
                    dodgeText.style.background = 'rgba(0, 0, 0, 0.7)';
                    dodgeText.style.padding = '4px 8px';
                    dodgeText.style.borderRadius = '4px';
                    dodgeText.style.fontSize = '16px';
                    dodgeText.textContent = isTeleport ? 'âš¡ Blink!' : 'ðŸŒŸ Dodge!';
                    document.getElementById('gameArea').appendChild(dodgeText);
                    setTimeout(() => dodgeText.remove(), 1000);

                    // Remove dodge effect after duration
                    setTimeout(() => {
                        removeDodgeEffect();
                    }, dodgeDuration);

                    playerStats.sp -= spCost;
                    updateDisplays();

                    // Show skill name
                    const skillNameText = document.createElement('div');
                    skillNameText.className = 'combat-text';
                    skillNameText.style.position = 'absolute';
                    skillNameText.style.left = (charX + 25) + 'px';
                    skillNameText.style.top = (charY - 60) + 'px';
                    skillNameText.style.background = elements[element].gradient;
                    skillNameText.style.color = elements[element].textColor;
                    skillNameText.style.padding = '4px 8px';
                    skillNameText.style.borderRadius = '4px';
                    skillNameText.style.fontWeight = 'bold';
                    skillNameText.style.fontSize = '16px';
                    skillNameText.textContent = skillName;
                    document.getElementById('gameArea').appendChild(skillNameText);
                    setTimeout(() => skillNameText.remove(), 1500);

                    // Use AI-determined cooldown
                    playerStats.skillCooldown = true;
                    setTimeout(() => {
                        playerStats.skillCooldown = false;
                    }, cooldownMs);

                    return;
                }

                // Rest of the existing skill effect code...
                const strBonus = type === 'melee' ? (playerStats.str * 0.1) : 0;
                const intBonus = type === 'ranged' ? (playerStats.int * 0.1) : 0;
                const lukBonus = Math.random() < (playerStats.luk * 0.01);
                const elementalMod = calculateElementalModifier(element, dummyElement);
                
                const burnAmplifier = element === 'fire' && activeStatusEffects.some(effect => effect.type === 'burn') 
                    ? statusEffects.burn.damageAmplifier 
                    : 1;
                
                const finalDamage = Math.floor(damage * (1 + strBonus + intBonus) * (lukBonus ? 2 : 1) * elementalMod * burnAmplifier);

                playerStats.sp -= spCost;
                updateDisplays();

                // Show skill name above player when skill is used
                const skillNameText = document.createElement('div');
                skillNameText.className = 'combat-text';
                skillNameText.style.position = 'absolute';
                skillNameText.style.left = (charX + 25) + 'px';
                skillNameText.style.top = (charY - 40) + 'px';
                skillNameText.style.background = elements[element].gradient;
                skillNameText.style.color = elements[element].textColor;
                skillNameText.style.padding = '4px 8px';
                skillNameText.style.borderRadius = '4px';
                skillNameText.style.fontWeight = 'bold';
                skillNameText.style.fontSize = '16px';
                skillNameText.textContent = skillName;
                document.getElementById('gameArea').appendChild(skillNameText);
                setTimeout(() => skillNameText.remove(), 1500);

                // Use AI-determined cooldown
                playerStats.skillCooldown = true;
                setTimeout(() => {
                    playerStats.skillCooldown = false;
                }, cooldownMs);

                if (type === 'ranged') {
                    const ballSize = 20 + (playerStats.dex * 2);
                    rangedBall.style.width = `${ballSize}px`;
                    rangedBall.style.height = `${ballSize}px`;
                    rangedBall.style.background = elements[element].gradient;
                    rangedBall.style.boxShadow = `0 0 10px ${elements[element].particleColor}`;
                    rangedBall.style.display = 'block';
                    
                    // Start from character center
                    let ballX = charX + 25;
                    let ballY = charY + 25;
                    rangedBall.style.left = ballX + 'px';
                    rangedBall.style.top = ballY + 'px';

                    // Get direction from WASD keys
                    let dx = 0;
                    let dy = 0;
                    if (pressedKeys.has('w')) dy -= 1;
                    if (pressedKeys.has('s')) dy += 1;
                    if (pressedKeys.has('a')) dx -= 1;
                    if (pressedKeys.has('d')) dx += 1;

                    // If no direction pressed, default to right
                    if (dx === 0 && dy === 0) {
                        dx = 1;
                    }

                    // Normalize diagonal movement
                    if (dx !== 0 && dy !== 0) {
                        const length = Math.sqrt(dx * dx + dy * dy);
                        dx /= length;
                        dy /= length;
                    }

                    const speed = 10; // Projectile speed
                    const moveBall = setInterval(() => {
                        ballX += dx * speed;
                        ballY += dy * speed;

                        // Check if ball hits dummy (now from any direction)
                        const dummyX = 450;
                        const dummyY = 175;
                        const distance = Math.sqrt(
                            Math.pow(ballX - dummyX, 2) + 
                            Math.pow(ballY - dummyY, 2)
                        );

                        if (distance < 50) { // Hit if within 50 pixels of dummy center
                            dummyHealth -= finalDamage;
                            if (dummyHealth < 0) dummyHealth = 0;
                            dummy.textContent = dummyHealth;
                            if (dummyHealth === 0) {
                                gainExp(50);
                            }

                            // Apply status effects on hit
                            if (element === 'fire') {
                                applyStatusEffect('burn', element);
                            } else if (element === 'poison') {
                                applyStatusEffect('poison', element);
                            } else if (element === 'water') {
                                applyStatusEffect('freeze', element);
                            }

                            // Show damage text
                            const damageText = document.createElement('div');
                            damageText.className = 'combat-text';
                            damageText.style.position = 'absolute';
                            damageText.style.left = '470px';
                            damageText.style.top = '150px';
                            damageText.style.background = elements[element].gradient;
                            damageText.style.color = elements[element].textColor;
                            damageText.style.padding = '4px 8px';
                            damageText.style.borderRadius = '4px';
                            damageText.style.fontWeight = 'bold';
                            damageText.style.fontSize = '20px';
                            damageText.textContent = finalDamage + (lukBonus ? ' CRIT!' : '');
                            document.getElementById('gameArea').appendChild(damageText);
                            setTimeout(() => damageText.remove(), 1500);

                            clearInterval(moveBall);
                            rangedBall.style.display = 'none';
                        } else if (ballX < 0 || ballX > 600 || ballY < 0 || ballY > 400) {
                            // Show "Miss!" text if projectile goes off screen
                            const missText = document.createElement('div');
                            missText.className = 'combat-text';
                            missText.style.left = '470px';
                            missText.style.top = '150px';
                            missText.style.color = '#ff4444';
                            missText.style.fontSize = '14px';
                            missText.textContent = "Miss!";
                            document.getElementById('gameArea').appendChild(missText);
                            setTimeout(() => missText.remove(), 1500);

                            clearInterval(moveBall);
                            rangedBall.style.display = 'none';
                        } else {
                            rangedBall.style.left = ballX + 'px';
                            rangedBall.style.top = ballY + 'px';
                        }
                    }, 16);
                } else {
                    character.style.background = elements[element].gradient;
                    character.style.boxShadow = `0 0 10px ${elements[element].particleColor}`;
                    // Calculate distance to dummy
                    const dummyX = 450;  // dummy's X position
                    const dummyY = 175;  // dummy's Y position
                    const distance = Math.sqrt(Math.pow(charX - dummyX, 2) + Math.pow(charY - dummyY, 2));
                    
                    // Only deal damage if within melee range (70 pixels)
                    if (distance <= 70) {
                        dummyHealth -= finalDamage;
                        if (dummyHealth < 0) dummyHealth = 0;
                        dummy.textContent = dummyHealth;
                        if (dummyHealth === 0) {
                            gainExp(50);
                        }

                        // Apply status effects only on hit for melee attacks
                        if (element === 'fire') {
                            applyStatusEffect('burn', element);
                        } else if (element === 'poison') {
                            applyStatusEffect('poison', element);
                        } else if (element === 'water') {
                            applyStatusEffect('freeze', element);
                        }
                        
                        // Only show damage text if we actually hit
                        const damageText = document.createElement('div');
                        damageText.className = 'combat-text';
                        damageText.style.position = 'absolute';
                        damageText.style.left = '470px';
                        damageText.style.top = '150px';
                        damageText.style.background = elements[element].gradient;
                        damageText.style.color = elements[element].textColor;
                        damageText.style.padding = '4px 8px';
                        damageText.style.borderRadius = '4px';
                        damageText.style.fontWeight = 'bold';
                        damageText.style.fontSize = '20px';
                        damageText.textContent = finalDamage + (lukBonus ? ' CRIT!' : '');
                        document.getElementById('gameArea').appendChild(damageText);
                        setTimeout(() => damageText.remove(), 1500);
                    } else {
                        // Show "Miss!" message if not in range
                        const missText = document.createElement('div');
                        missText.className = 'combat-text';
                        missText.style.left = (charX + 25) + 'px';
                        missText.style.top = (charY - 20) + 'px';
                        missText.style.color = '#ff4444';
                        missText.style.fontSize = '14px';
                        missText.textContent = "Miss!";
                        document.getElementById('gameArea').appendChild(missText);
                        setTimeout(() => missText.remove(), 1500);
                    }
                    setTimeout(() => {
                        character.style.background = 'blue';
                        character.style.boxShadow = 'none';
                    }, 200);
                }
            };
        }

        // Modified resetDummy to restore some SP
        function resetDummy() {
            dummyHealth = 100;
            dummy.textContent = dummyHealth;
            playerStats.sp = Math.min(playerStats.maxSp, playerStats.sp + 20); // Restore some SP
            updateDisplays();
        }

        // Track pressed keys for smooth movement
        const pressedKeys = new Set();
        const moveSpeed = 5; // Adjust movement speed

        // Move character based on pressed keys
        function updateCharacterPosition() {
            // Diagonal movement should not be faster than cardinal movement
            let dx = 0;
            let dy = 0;

            if (pressedKeys.has('w')) dy -= 1;
            if (pressedKeys.has('s')) dy += 1;
            if (pressedKeys.has('a')) dx -= 1;
            if (pressedKeys.has('d')) dx += 1;

            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707; // Math.cos(45 degrees)
                dy *= 0.707; // Math.sin(45 degrees)
            }

            // Update position with boundary checking
            const newX = charX + dx * moveSpeed;
            const newY = charY + dy * moveSpeed;

            if (newX >= 0 && newX <= 550) charX = newX;
            if (newY >= 0 && newY <= 350) charY = newY;

            character.style.left = charX + 'px';
            character.style.top = charY + 'px';
        }

        // Start movement loop
        const movementLoop = setInterval(updateCharacterPosition, 16); // ~60fps

        // Handle keydown
        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            
            // Only handle WASD if we're not typing in the input field
            if (['w', 'a', 's', 'd'].includes(key) && document.activeElement !== skillInput) {
                pressedKeys.add(key);
                event.preventDefault(); // Prevent scrolling
            }

            // Handle skill shortcuts
            if (isListeningForKey) return; // Don't trigger skills while rebinding
            
            // Find which skill this key is bound to
            Object.keys(keyBindings).forEach(skillKey => {
                const binding = keyBindings[skillKey];
                // Check if the pressed key matches the binding
                // Handle special case for spacebar
                if ((key === binding.key) || (key === ' ' && binding.key === ' ')) {
                    const skillIndex = parseInt(skillKey.replace('skill', '')) - 1;
                    if (skillIndex >= 0 && skillIndex < skills.length) {
                        skills[skillIndex].effect();
                    }
                }
            });
        });

        // Handle keyup
        document.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            if (['w', 'a', 's', 'd'].includes(key)) {
                pressedKeys.delete(key);
            }
        });

        // Clean up movement loop when window loses focus
        window.addEventListener('blur', () => {
            pressedKeys.clear();
        });

        // AI-based skill generation
        async function createSkill() {
            const prompt = skillInput.value.trim();
            if (!prompt) return;

            // Show loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'ai-loading';
            loadingDiv.textContent = 'ðŸ¤– AI is generating your skill...';
            skillInput.parentNode.insertBefore(loadingDiv, skillInput.nextSibling);
            loadingDiv.style.display = 'block';

            // Create error display
            const errorDiv = document.createElement('div');
            errorDiv.className = 'ai-error';
            skillInput.parentNode.insertBefore(errorDiv, loadingDiv.nextSibling);

            try {
                console.log('Sending prompt to AI:', prompt);
                const response = await fetch('http://localhost:11434/api/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'llama3',
                        prompt: `You are an expert game balance designer specializing in RPG combat systems. Create a balanced skill based on this description: "${prompt}".

                        ANALYZE THE SKILL DESCRIPTION FOR:
                        1. Complexity (simple attack vs. complex combo)
                        2. Range (melee vs. ranged)
                        3. Area of Effect (single target vs. AoE)
                        4. Status Effects (none, burn, poison, freeze)
                        5. Utility (pure damage vs. utility/control)
                        6. Theme and Power Fantasy

                        BALANCE GUIDELINES:
                        1. SP Cost (5-50):
                           - Basic attacks: 5-15 SP
                           - Standard skills: 15-30 SP
                           - Complex/Powerful skills: 30-50 SP
                           - Status effects add +5-10 SP
                           - AoE adds +10-15 SP
                           - Melee skills cost 20% less than ranged
                           
                        2. Cooldown (200-3000ms):
                           - Basic attacks: 200-500ms
                           - Standard skills: 500-1500ms
                           - Ultimate/Powerful: 1500-3000ms
                           - Reduce by 20% for utility skills
                           - Increase by 30% for AoE
                           - Melee skills have 25% lower cooldown
                           
                        3. Damage (5-30):
                           - Melee Basic: 8-15 (Higher risk, higher reward)
                           - Ranged Basic: 5-10 (Safer, lower damage)
                           - Melee Standard: 15-25
                           - Ranged Standard: 10-20
                           - Melee Ultimate: 25-35
                           - Ranged Ultimate: 20-30
                           - Reduce by 30% if has status effects
                           - Reduce by 20% if AoE
                           - Neutral skills deal 50% damage
                           - Melee gets +25% STR scaling

                        4. Power Level:
                           LOW: Basic attacks, simple utility
                           MEDIUM: Standard damage/utility skills
                           HIGH: Ultimate abilities, complex combos

                        5. Risk-Reward Factors:
                           - Melee range is 70 pixels
                           - Ranged has projectile travel time
                           - Melee gets better stat scaling
                           - Melee has lower costs and cooldowns

                        Return ONLY a JSON object with these fields:
                        {
                            "name": "skill name",
                            "type": "melee" or "ranged",
                            "element": "fire", "water", "wind", "poison", or "neutral",
                            "damage": number between 5-35,
                            "spCost": number between 5-50,
                            "cooldownMs": number between 200-3000,
                            "description": "skill description",
                            "powerLevel": "low", "medium", or "high",
                            "hasStatusEffect": boolean,
                            "isAoE": boolean,
                            "utilityValue": number between 0-10
                        }

                        IMPORTANT: Return ONLY the JSON object, no other text.`
                    })
                });

                // Read the streaming response
                const reader = response.body.getReader();
                let fullResponse = '';
                
                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    
                    // Convert the Uint8Array to text
                    const chunk = new TextDecoder().decode(value);
                    try {
                        // Parse the chunk as JSON
                        const jsonChunk = JSON.parse(chunk);
                        if (jsonChunk.response) {
                            fullResponse += jsonChunk.response;
                        }
                    } catch (e) {
                        console.warn('Error parsing chunk:', e);
                        fullResponse += chunk;
                    }
                }

                console.log('Full Response:', fullResponse);
                let skillData;
                let isDodgeSkill = false;

                try {
                    // Look for a JSON object in the response
                    const jsonMatch = fullResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        const jsonStr = jsonMatch[0].replace(/\\n/g, '').replace(/\s+/g, ' ');
                        skillData = JSON.parse(jsonStr);
                        console.log('Parsed Skill Data:', skillData);
                        
                        // Check if it's a dodge skill
                        isDodgeSkill = prompt.toLowerCase().includes('dodge') || 
                                     prompt.toLowerCase().includes('evade') || 
                                     prompt.toLowerCase().includes('blink');

                        // Create the skill
                        const skill = {
                            name: skillData.name,
                            effect: createSkillEffect(
                                skillData.type,
                                skillData.color,
                                skillData.damage,
                                skillData.spCost,
                                skillData.element,
                                skillData.name,
                                isDodgeSkill,
                                skillData.cooldownMs
                            ),
                            description: generateTechnicalDescription(skillData, isDodgeSkill),
                            damage: skillData.damage,
                            element: skillData.element,
                            spCost: skillData.spCost,
                            cooldownMs: skillData.cooldownMs,
                            isDodgeSkill: isDodgeSkill,
                            powerLevel: skillData.powerLevel
                        };

                        // Add success feedback
                        console.log('Skill created successfully:', skill);
                        const successDiv = document.createElement('div');
                        successDiv.style.color = '#4CAF50';
                        successDiv.style.marginTop = '5px';
                        successDiv.textContent = 'âœ¨ Skill generated successfully!';
                        skillInput.parentNode.insertBefore(successDiv, errorDiv);
                        setTimeout(() => successDiv.remove(), 2000);

                        skills.push(skill);
                        updateSkillList();
                        skillInput.value = '';
                    } else {
                        throw new Error('No JSON found in response');
                    }
                } catch (e) {
                    console.error('AI parsing error:', e);
                    errorDiv.textContent = 'âš ï¸ AI response format error, using fallback system';
                    errorDiv.style.display = 'block';
                    setTimeout(() => errorDiv.style.display = 'none', 3000);
                    
                    // Use the fallback system
                    const text = prompt.toLowerCase();
                    const isDodgeSkill = text.includes('dodge') || text.includes('evade') || text.includes('blink');
                    const isAoE = text.includes('area') || text.includes('aoe') || text.includes('explosion') || text.includes('wave');
                    const hasStatusEffect = text.includes('burn') || text.includes('freeze') || text.includes('poison');
                    const isBasicAttack = text.includes('basic') || text.includes('normal') || text.includes('simple');
                    const isPowerful = text.includes('ultimate') || text.includes('powerful') || text.includes('massive');
                    const isMelee = !text.includes('shoot') && !text.includes('beam') && !text.includes('ball');

                    // Create fallback skill data
                    skillData = {
                        name: prompt.charAt(0).toUpperCase() + prompt.slice(1),
                        type: isMelee ? 'melee' : 'ranged',
                        element: text.includes('fire') ? 'fire' : 
                                text.includes('ice') || text.includes('water') ? 'water' : 
                                text.includes('wind') ? 'wind' : 
                                text.includes('poison') ? 'poison' : 'neutral',
                        damage: isMelee ? 
                            (isBasicAttack ? 8 + Math.floor(Math.random() * 8) : // 8-15
                             isPowerful ? 25 + Math.floor(Math.random() * 11) : // 25-35
                             15 + Math.floor(Math.random() * 11)) : // 15-25
                            (isBasicAttack ? 5 + Math.floor(Math.random() * 6) : // 5-10
                             isPowerful ? 20 + Math.floor(Math.random() * 11) : // 20-30
                             10 + Math.floor(Math.random() * 11)), // 10-20
                        spCost: Math.floor((isBasicAttack ? 5 + Math.random() * 11 : // 5-15
                                          isPowerful ? 30 + Math.random() * 21 : // 30-50
                                          15 + Math.random() * 16) * // 15-30
                                         (isMelee ? 0.8 : 1)), // 20% less for melee
                        cooldownMs: Math.floor((isBasicAttack ? 200 + Math.random() * 301 : // 200-500
                                              isPowerful ? 1500 + Math.random() * 1501 : // 1500-3000
                                              500 + Math.random() * 1001) * // 500-1500
                                             (isMelee ? 0.75 : 1)), // 25% lower for melee
                        description: generateWoWDescription(prompt),
                        powerLevel: isPowerful ? "high" : isBasicAttack ? "low" : "medium",
                        hasStatusEffect: hasStatusEffect,
                        isAoE: isAoE,
                        utilityValue: isDodgeSkill ? 8 : hasStatusEffect ? 5 : 2
                    };

                    // Create the skill using fallback data
                    const skill = {
                        name: skillData.name,
                        effect: createSkillEffect(
                            skillData.type,
                            elements[skillData.element].color,
                            skillData.damage,
                            skillData.spCost,
                            skillData.element,
                            skillData.name,
                            isDodgeSkill,
                            skillData.cooldownMs
                        ),
                        description: generateTechnicalDescription(skillData, isDodgeSkill),
                        damage: skillData.damage,
                        element: skillData.element,
                        spCost: skillData.spCost,
                        cooldownMs: skillData.cooldownMs,
                        isDodgeSkill: isDodgeSkill,
                        powerLevel: skillData.powerLevel
                    };

                    skills.push(skill);
                    updateSkillList();
                    skillInput.value = '';
                }
            } catch (error) {
                console.error('Error creating skill:', error);
                errorDiv.textContent = `âŒ Error: ${error.message}`;
                errorDiv.style.display = 'block';
                setTimeout(() => errorDiv.style.display = 'none', 3000);
            } finally {
                loadingDiv.remove();
            }
        }

        // Enhanced creative skill description generation
        function generateWoWDescription(prompt) {
            const text = prompt.toLowerCase();
            
            // Extract key characteristics
            const isMelee = !text.includes('shoot') && !text.includes('beam') && !text.includes('ball');
            const isDodge = text.includes('dodge') || text.includes('evade') || text.includes('blink');
            const isUltimate = text.includes('ultimate') || text.includes('powerful') || text.includes('massive');
            
            // Determine element and its characteristics
            const elementMap = {
                fire: {
                    element: 'fire',
                    adjectives: ['blazing', 'infernal', 'scorching', 'searing', 'volcanic'],
                    nouns: ['flames', 'inferno', 'blaze', 'firestorm', 'conflagration'],
                    verbs: ['ignites', 'incinerates', 'immolates', 'scorches', 'burns'],
                    effects: ['reducing them to ash', 'leaving only cinders in your wake', 'melting everything in its path', 'creating a devastating inferno']
                },
                water: {
                    element: 'water',
                    adjectives: ['frozen', 'glacial', 'arctic', 'crystalline', 'frigid'],
                    nouns: ['ice', 'frost', 'blizzard', 'avalanche', 'glacier'],
                    verbs: ['freezes', 'chills', 'crystallizes', 'entombs', 'flash-freezes'],
                    effects: ['encasing them in ice', 'shattering their defenses', 'freezing them to their core', 'creating a field of absolute zero']
                },
                wind: {
                    element: 'wind',
                    adjectives: ['tempestuous', 'storming', 'howling', 'cyclonic', 'turbulent'],
                    nouns: ['gale', 'tempest', 'hurricane', 'storm', 'whirlwind'],
                    verbs: ['slices', 'shreds', 'buffets', 'tears through', 'rends'],
                    effects: ['leaving them scattered to the winds', 'creating a devastating vacuum', 'shredding everything in its path', 'forming a destructive cyclone']
                },
                poison: {
                    element: 'poison',
                    adjectives: ['virulent', 'toxic', 'pestilent', 'corrupting', 'venomous'],
                    nouns: ['toxin', 'venom', 'plague', 'miasma', 'corruption'],
                    verbs: ['corrupts', 'infects', 'poisons', 'contaminates', 'taints'],
                    effects: ['melting their very essence', 'spreading unstoppable decay', 'corrupting their life force', 'leaving only decay in its wake']
                },
                neutral: {
                    element: 'force',
                    adjectives: ['mystical', 'arcane', 'ethereal', 'cosmic', 'primal'],
                    nouns: ['energy', 'force', 'power', 'essence', 'might'],
                    verbs: ['strikes', 'crushes', 'devastates', 'overwhelms', 'annihilates'],
                    effects: ['warping reality itself', 'shattering the laws of nature', 'creating a cascade of raw power', 'bending space and time']
                }
            };

            // Determine element based on skill description
            let elementType = 'neutral';
            for (const element in elementMap) {
                if (text.includes(element)) {
                    elementType = element;
                    break;
                }
            }
            
            const elem = elementMap[elementType];
            
            // Random selection helpers
            const pick = arr => arr[Math.floor(Math.random() * arr.length)];
            
            if (isDodge) {
                const dodgeDescriptions = [
                    `Channel the power of ${pick(elem.nouns)} to ${pick(['phase through reality', 'bend space-time', 'transcend physical bounds', 'defy the laws of nature'])}, becoming momentarily ${pick(['ethereal', 'invulnerable', 'untouchable', 'ghostlike'])} as you ${pick(['dance between dimensions', 'slip through the fabric of reality', 'move with supernatural grace', 'traverse the void itself'])}.`,
                    `Harness ${pick(elem.adjectives)} energy to ${pick(['fold space', 'manipulate reality', 'distort dimensions', 'bend the laws of physics'])}, allowing you to ${pick(['blink through the ethereal plane', 'phase through the material world', 'step between moments in time', 'transcend physical barriers'])} with the grace of a cosmic dancer.`,
                    `Invoke ancient ${elem.element} magic to ${pick(['meld with the shadows', 'become one with the void', 'transcend mortal bounds', 'defy physical laws'])}, granting a moment of perfect ${pick(['transcendence', 'invulnerability', 'ethereality', 'dimensional shift'])} as you ${pick(['weave through reality', 'dance between worlds', 'slip through space-time', 'move like living mist'])}.`
                ];
                return pick(dodgeDescriptions);
            }

            if (isMelee) {
                const meleeDescriptions = [
                    `Unleash a devastating ${pick(elem.adjectives)} assault that ${pick(elem.verbs)} your enemies with ${pick(['unrelenting', 'overwhelming', 'unstoppable', 'devastating'])} force, ${pick(elem.effects)}. Each strike resonates with the power of ${pick(['ancient gods', 'primal forces', 'cosmic might', 'elemental fury'])}.`,
                    `Channel pure ${elem.element} into a ${pick(['devastating', 'cataclysmic', 'earth-shattering', 'reality-warping'])} series of strikes, ${pick(elem.verbs)} your foes as ${pick(['reality warps', 'space distorts', 'time fractures', 'dimensions collapse'])} around you, ${pick(elem.effects)}.`,
                    `Become one with the essence of ${elem.element}, transforming your strikes into ${pick(elem.adjectives)} manifestations of pure destruction that ${pick(elem.verbs)} anything in their path, ${pick(elem.effects)} while ${pick(['reality trembles', 'the air screams', 'space fractures', 'time holds its breath'])}.`
                ];
                return pick(meleeDescriptions);
            } else {
                const rangedDescriptions = [
                    `Conjure a ${pick(elem.adjectives)} manifestation of pure ${elem.element} that ${pick(['spirals', 'weaves', 'tears', 'rips'])} through the fabric of reality, ${pick(elem.verbs)} your enemies as it ${pick(['defies physics', 'warps space', 'bends time', 'shatters dimensions'])}, ${pick(elem.effects)}.`,
                    `Summon forth a ${pick(elem.adjectives)} torrent of ${pick(elem.nouns)} that ${pick(['cascades', 'erupts', 'surges', 'storms'])} across the battlefield, ${pick(elem.verbs)} all who stand before you while ${pick(['reality buckles', 'the air screams', 'space distorts', 'time fragments'])}, ${pick(elem.effects)}.`,
                    `Channel the primal essence of ${elem.element} into a ${pick(elem.adjectives)} projectile that ${pick(['screams', 'howls', 'roars', 'thunders'])} through the air, ${pick(elem.verbs)} your foes as it ${pick(['tears reality asunder', 'shatters the material plane', 'ruptures the fabric of space', 'fractures the bounds of existence'])}, ${pick(elem.effects)}.`
                ];
                return pick(rangedDescriptions);
            }
        }

        // Update technical description to show AI-determined values
        function generateTechnicalDescription(skillData, isDodgeSkill) {
            const element = elements[skillData.element];
            const cooldownSec = (skillData.cooldownMs / 1000).toFixed(1);
            const powerLevelColors = {
                low: '#4CAF50',    // Green
                medium: '#FFA726',  // Orange
                high: '#F44336'     // Red
            };
            
            return `<div class="element-tag" style="background: ${element.gradient}; color: ${element.textColor}">
                        ${element.name}${isDodgeSkill ? ' - Dodge' : ''}
                    </div>
                    ${skillData.description}
                    
                    <div class="technical-details">
                        <strong>Technical Details:</strong>
                        ${isDodgeSkill 
                            ? `â€¢ Effect: 1 second invulnerability\nâ€¢ Dodge Chance: 100%` 
                            : `â€¢ Base Damage: ${skillData.damage}`}
                        â€¢ SP Cost: ${skillData.spCost}
                        â€¢ Cooldown: ${cooldownSec}s
                        â€¢ Type: ${isDodgeSkill ? 'Dodge' : skillData.type.charAt(0).toUpperCase() + skillData.type.slice(1)}
                        â€¢ Power Level: <span style="color: ${powerLevelColors[skillData.powerLevel.toLowerCase()]}">${skillData.powerLevel.toUpperCase()}</span>
                        
                        <strong>Element Properties:</strong>
                        â€¢ ${element.description}
                        â€¢ Strong vs: ${element.strongAgainst.length ? element.strongAgainst.map(e => elements[e].name).join(', ') : 'None'}
                        â€¢ Weak vs: ${element.weakAgainst.length ? element.weakAgainst.map(e => elements[e].name).join(', ') : 'None'}
                    </div>`;
        }

        // Show skills with descriptions
        function updateSkillList() {
            skillList.innerHTML = '';
            skills.forEach((skill, index) => {
                const skillDiv = document.createElement('div');
                skillDiv.className = 'skill';
                
                const skillHeader = document.createElement('div');
                skillHeader.className = 'skill-header';
                
                const button = document.createElement('button');
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = skill.name;
                
                const shortcutSpan = document.createElement('span');
                shortcutSpan.className = 'skill-shortcut';
                const binding = keyBindings[`skill${index + 1}`];
                shortcutSpan.textContent = `[${binding.display}]`;
                
                // Add click handler for shortcut rebinding
                shortcutSpan.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent triggering the skill
                    
                    // Reset any other shortcuts
                    document.querySelectorAll('.skill-shortcut').forEach(s => {
                        s.classList.remove('listening');
                    });
                    
                    // Set up listening state
                    isListeningForKey = true;
                    currentBindingSkill = `skill${index + 1}`;
                    shortcutSpan.classList.add('listening');
                    
                    // Show tooltip near the shortcut
                    const rect = shortcutSpan.getBoundingClientRect();
                    shortcutTooltip.style.display = 'block';
                    shortcutTooltip.style.left = `${rect.left}px`;
                    shortcutTooltip.style.top = `${rect.top - 40}px`;
                    
                    // Add temporary event listener
                    document.addEventListener('keydown', handleKeyBinding);
                    
                    // Cancel listening if clicked elsewhere
                    const cancelListener = (e) => {
                        if (!shortcutSpan.contains(e.target)) {
                            isListeningForKey = false;
                            currentBindingSkill = null;
                            shortcutSpan.classList.remove('listening');
                            shortcutTooltip.style.display = 'none';
                            document.removeEventListener('keydown', handleKeyBinding);
                            document.removeEventListener('click', cancelListener);
                        }
                    };
                    document.addEventListener('click', cancelListener);
                });
                
                button.appendChild(nameSpan);
                button.appendChild(shortcutSpan);
                button.style.background = elements[skill.element].gradient;
                button.style.color = elements[skill.element].textColor;
                button.onclick = skill.effect;
                
                const removeButton = document.createElement('button');
                removeButton.className = 'remove-skill';
                removeButton.textContent = 'âœ•';
                removeButton.onclick = (e) => {
                    e.stopPropagation();
                    skills.splice(index, 1);
                    updateSkillList();
                };
                
                skillHeader.appendChild(button);
                skillHeader.appendChild(removeButton);
                
                const desc = document.createElement('div');
                desc.className = 'skill-description';
                desc.innerHTML = skill.description;
                
                skillDiv.appendChild(skillHeader);
                skillDiv.appendChild(desc);
                skillList.appendChild(skillDiv);
            });
        }

        // Add SP regeneration function
        function startSpRegeneration() {
            setInterval(() => {
                const now = Date.now();
                const timePassed = now - playerStats.lastSpRegen;
                
                // Base SP regen per second (similar to RO's system)
                const baseRegen = 1;
                // INT bonus: Every 1 INT adds 0.2 SP per second
                const intBonus = (playerStats.int - 1) * 0.2;
                
                // Calculate SP to regenerate based on time passed and round to 3 decimal places
                const regenAmount = ((baseRegen + intBonus) * (timePassed / 1000));
                
                // Add SP and round to 3 decimal places
                playerStats.sp = Math.min(playerStats.maxSp, Math.round((playerStats.sp + regenAmount) * 1000) / 1000);
                playerStats.lastSpRegen = now;
                
                // Update displays
                updateDisplays();
            }, 100); // Update every 100ms for smooth regeneration
        }

        // Initialize displays and start SP regeneration
        updateDisplays();
        startSpRegeneration();

        // Initialize element selector
        addElementSelector();

        // Potion system
        let activePotion = null;
        const POTION_SPAWN_CHANCE = 0.02; // 2% chance per second (increased from 0.5%)
        const POTION_HEAL_AMOUNT = 50;
        const POTION_SP_AMOUNT = 30;

        function spawnPotion() {
            if (activePotion) return; // Only one potion at a time
            
            if (Math.random() < POTION_SPAWN_CHANCE) {
                const potion = document.createElement('div');
                const isHpPotion = Math.random() < 0.3; // 30% chance for HP, 70% for SP
                
                potion.className = `potion ${isHpPotion ? 'hp-potion' : 'sp-potion'}`;
                // Random position within game area bounds
                const x = Math.floor(Math.random() * 550);
                const y = Math.floor(Math.random() * 350);
                
                potion.style.left = x + 'px';
                potion.style.top = y + 'px';
                
                potion.onclick = () => {
                    collectPotion(potion, isHpPotion, x, y);
                };
                
                document.getElementById('gameArea').appendChild(potion);
                activePotion = potion;
                
                // Remove potion after 10 seconds if not collected
                setTimeout(() => {
                    if (activePotion === potion) {
                        if (potion.parentNode) {
                            potion.parentNode.removeChild(potion);
                        }
                        activePotion = null;
                    }
                }, 10000);
            }
        }

        function collectPotion(potion, isHpPotion, x, y) {
            if (isHpPotion) {
                playerStats.hp = Math.min(playerStats.maxHp, playerStats.hp + POTION_HEAL_AMOUNT);
                showPotionEffect(x, y, `+${POTION_HEAL_AMOUNT} HP`, '#ff6b6b');
                // Remove poison effect when HP potion is collected
                activeStatusEffects = activeStatusEffects.filter(effect => effect.type !== 'poison');
                moveSpeed = baseMovementSpeed; // Restore normal movement speed
                updateDummyAppearance();
            } else {
                playerStats.sp = Math.min(playerStats.maxSp, playerStats.sp + POTION_SP_AMOUNT);
                showPotionEffect(x, y, `+${POTION_SP_AMOUNT} SP`, '#6b88ff');
            }
            updateDisplays();
            document.getElementById('gameArea').removeChild(potion);
            activePotion = null;
        }

        function showPotionEffect(x, y, text, color) {
            const effect = document.createElement('div');
            effect.className = 'combat-text';
            effect.style.left = x + 'px';
            effect.style.top = y + 'px';
            effect.style.color = color;
            effect.style.fontSize = '16px';
            effect.textContent = text;
            document.getElementById('gameArea').appendChild(effect);
            setTimeout(() => effect.remove(), 1500);
        }

        // Start potion spawn check every second
        setInterval(spawnPotion, 1000);

        // Add after character creation
        let keyBindings = {
            skill1: { key: '1', display: '1' },
            skill2: { key: '2', display: '2' },
            skill3: { key: '3', display: '3' },
            skill4: { key: '4', display: '4' }
        };

        // Add to localStorage initialization with new format
        if (!localStorage.getItem('keyBindings')) {
            localStorage.setItem('keyBindings', JSON.stringify(keyBindings));
        } else {
            keyBindings = JSON.parse(localStorage.getItem('keyBindings'));
        }

        let isListeningForKey = false;
        let currentBindingSkill = null;

        // Create tooltip element
        const shortcutTooltip = document.createElement('div');
        shortcutTooltip.className = 'shortcut-tooltip';
        shortcutTooltip.textContent = 'Click to change shortcut...';
        document.body.appendChild(shortcutTooltip);

        function getKeyDisplay(event) {
            if (event.key === ' ') return 'SPACE';
            if (event.key === 'Meta') return 'âŒ˜';
            if (event.key === 'Alt') return 'Alt';
            if (event.key === 'Control') return 'Ctrl';
            if (event.key === 'Shift') return 'â‡§';
            return event.key.toUpperCase();
        }

        function updateKeyBindDisplay() {
            document.querySelectorAll('.skill-shortcut').forEach((shortcut, index) => {
                const skillNum = index + 1;
                const binding = keyBindings[`skill${skillNum}`];
                shortcut.textContent = `[${binding.display}]`;
            });
        }

        function handleKeyBinding(event) {
            if (!isListeningForKey || !currentBindingSkill) return;
            
            event.preventDefault();
            
            const key = event.key.toLowerCase();
            
            // Check for reserved movement keys
            const reservedKeys = ['w', 'a', 's', 'd'];
            if (reservedKeys.includes(key)) {
                // Show warning message
                const warning = document.createElement('div');
                warning.className = 'warning-message';
                warning.textContent = `Cannot bind movement key "${key.toUpperCase()}"!`;
                warning.style.left = shortcutTooltip.style.left;
                warning.style.top = shortcutTooltip.style.top;
                document.body.appendChild(warning);
                
                // Remove warning after animation
                setTimeout(() => warning.remove(), 2000);
                
                return;
            }
            
            // Get the key display and actual key value
            const display = getKeyDisplay(event);
            
            // Remove old binding
            Object.keys(keyBindings).forEach(skill => {
                if (keyBindings[skill].key === key) {
                    keyBindings[skill] = { key: '', display: '' };
                }
            });
            
            // Set new binding
            keyBindings[currentBindingSkill] = {
                key: key,
                display: display
            };
            
            // Save to localStorage
            localStorage.setItem('keyBindings', JSON.stringify(keyBindings));
            
            // Update displays
            updateKeyBindDisplay();
            
            // Reset listening state
            isListeningForKey = false;
            currentBindingSkill = null;
            document.querySelectorAll('.skill-shortcut').forEach(shortcut => {
                shortcut.classList.remove('listening');
            });
            shortcutTooltip.style.display = 'none';
            
            // Remove the temporary event listener
            document.removeEventListener('keydown', handleKeyBinding);
        }

        // Initialize key bindings display
        document.addEventListener('DOMContentLoaded', () => {
            updateKeyBindDisplay();
        });

        document.addEventListener('keydown', function(event) {
            if (isBindingKey) {
                event.preventDefault();
                
                // Check for WASD and modifier combinations
                const movementKeys = ['w', 'a', 's', 'd'];
                const isMovementKey = movementKeys.includes(event.key.toLowerCase());
                const hasModifier = event.ctrlKey || event.metaKey || event.altKey;

                if (isMovementKey || (hasModifier && isMovementKey)) {
                    const modifierText = hasModifier ? 
                        `${event.ctrlKey ? 'Ctrl+' : ''}${event.metaKey ? 'Cmd+' : ''}${event.altKey ? 'Alt+' : ''}` : '';
                    
                    showWarningMessage(`Cannot bind ${modifierText}${event.key.toUpperCase()} - Reserved for movement!`);
                    return;
                }

                // Get the key display value
                let keyDisplay = event.key;
                if (event.key === ' ') keyDisplay = 'Space';
                if (event.key.length === 1) keyDisplay = event.key.toUpperCase();
                
                // Update the key binding
                const skillId = currentBindingSkill;
                keyBindings[skillId] = {
                    key: event.key,
                    display: keyDisplay
                };
                
                // Update the display and save
                document.querySelector(`[data-skill-id="${skillId}"] .shortcut`).textContent = keyDisplay;
                localStorage.setItem('keyBindings', JSON.stringify(keyBindings));
                
                isBindingKey = false;
                currentBindingSkill = null;
                return;
            }

            // Handle normal key press for skills
            if (!event.ctrlKey && !event.metaKey && !event.altKey) {
                handleSkillKeyPress(event.key);
            }
        });

        // Helper function to show warning message
        function showWarningMessage(message) {
            const warningMessage = document.createElement('div');
            warningMessage.className = 'warning-message';
            warningMessage.textContent = message;
            warningMessage.style.top = '50%';
            warningMessage.style.left = '50%';
            warningMessage.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(warningMessage);
            
            setTimeout(() => {
                warningMessage.remove();
            }, 2000);
        }

        if (playerStats.experience >= playerStats.experienceToNextLevel) {
            playerStats.level++;
            playerStats.experience = 0;
            playerStats.experienceToNextLevel = Math.floor(playerStats.experienceToNextLevel * 1.5);
            
            // Restore HP/SP on level up
            playerStats.hp = playerStats.maxHp;
            playerStats.sp = playerStats.maxSp;

            // Show floating level up text
            const levelUpText = document.createElement('div');
            levelUpText.className = 'floating-text level-up';
            levelUpText.textContent = `Level Up! ${playerStats.level}`;
            levelUpText.style.position = 'absolute';
            levelUpText.style.left = `${character.offsetLeft + character.offsetWidth / 2}px`;
            levelUpText.style.top = `${character.offsetTop - 20}px`;
            document.getElementById('gameArea').appendChild(levelUpText);

            // Remove the text after animation
            setTimeout(() => {
                levelUpText.remove();
            }, 2000);

            updateStats();
        }
    </script>
</body>
</html>