<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My AI Skill Game with Ollama</title>
    <style>
        :root {
            /* Game dimensions */
            --game-width: 1366px;
            --game-height: 768px;
            /* Entity sizes */
            --character-size: 50px;
            --projectile-size: 20px;
        }

        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #gameArea {
            width: var(--game-width);
            height: var(--game-height);
            border: 2px solid #333;
            background: #2a2a2a;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* Character and Dummy */
        #character {
            width: var(--character-size);
            height: var(--character-size);
            background: #4a90e2;
            border-radius: 50%;
            position: absolute;
            top: 384px;  /* Centered vertically */
            left: 683px; /* Centered horizontally */
            box-shadow: 0 0 10px rgba(74, 144, 226, 0.5);
        }

        #dummy {
            width: var(--character-size);
            height: var(--character-size);
            background: #e24a4a;
            border-radius: 50%;
            position: absolute;
            top: 384px;  /* Centered vertically */
            left: 1024px; /* 3/4 of the width */
            text-align: center;
            line-height: var(--character-size);
            color: white;
            box-shadow: 0 0 10px rgba(226, 74, 74, 0.5);
        }

        #rangedBall {
            width: var(--projectile-size);
            height: var(--projectile-size);
            background: red;
            border-radius: 50%;
            position: absolute;
            display: none;
        }

        /* Stats Panel - Upper Left */
        #statsPanel {
            position: absolute;
            top: 150px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(5px);
            min-width: 200px;
        }

        /* HP/SP Bars - Upper Left, next to Stats */
        #hpSpBar {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .bar {
            width: 150px;
            height: 12px;
            margin: 5px 0;
            border-radius: 6px;
            overflow: hidden;
        }

        #hpBar, #spBar { 
            background: #333;
            width: 150px;
            height: 12px;
            margin: 5px 0;
            border-radius: 6px;
            overflow: hidden;
        }

        #hpFill, #spFill {
            width: 100%;
            height: 100%;
            transition: width 0.3s ease;
        }

        #hpFill {
            background: linear-gradient(to right, #ff4444, #ff6b6b);
        }

        #spFill {
            background: linear-gradient(to right, #4444ff, #6b6bff);
        }

        /* Skills - Center Bottom */
        #skillList {
            position: absolute;
            bottom: 0px;
            left: 50%;
            transform: translateX(-50%);
            width: 1080px;
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .skill {
            flex: 0 0 auto;
            margin: 0 5px;
            position: relative;
        }

        .skill button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .skill button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Skill Description Tooltip */
        .skill-description {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: #e8e8e8;
            padding: 12px 15px;
            border-radius: 8px;
            font-size: 13px;
            width: max-content;
            max-width: 300px;
            white-space: normal;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(8px);
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.15);
            line-height: 1.5;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            letter-spacing: 0.2px;
        }

        .skill-description h3 {
            color: #fff;
            font-size: 14px;
            margin: 0 0 8px 0;
            font-weight: 600;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 6px;
        }

        .skill-description .description {
            color: #d4d4d4;
            margin: 8px 0;
            font-style: italic;
        }

        .skill-description .stats {
            color: #b8b8b8;
            font-size: 12px;
            margin: 8px 0;
            padding: 8px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .skill-description .stats div {
            margin: 4px 0;
        }

        .skill-description .element {
            font-weight: 500;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
        }

        .skill-description .damage {
            color: #ff7676;
        }

        .skill-description .sp-cost {
            color: #7676ff;
        }

        .skill-description .cooldown {
            color: #76ff76;
        }

        .skill-description .element-description {
            font-size: 12px;
            margin: 6px 0 10px 0;
            padding: 0 6px;
            font-style: italic;
        }

        .skill-description .element-info {
            font-size: 12px;
            margin-top: 8px;
            color: #a8a8a8;
        }

        .skill-description .element-info div {
            margin: 4px 0;
        }

        .skill:hover .skill-description {
            opacity: 1;
        }

        /* Input and Controls - Upper Right */
        #skillInput {
            position: absolute;
            top: calc(var(--game-height) * 0.15);  /* 20% from top */
            right: calc(var(--game-width) * 0.5);  /* 10% from right */
            width: calc(var(--game-width) * 0.25);  /* 25% of game width */
            padding: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 4px;
            color: white;
            font-family: inherit;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s ease;
            z-index: 100;
        }

        #skillInput:focus {
            border-color: #666;
        }

        #skillInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        /* Combat Text and Effects */
        .combat-text {
            position: absolute;
            font-weight: bold;
            animation: floatUp 1.5s ease-out forwards;
            text-shadow: 0px 0px 3px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 1000;
        }

        /* Potions */
        .potion {
            width: 20px;
            height: 20px;
            position: absolute;
            border-radius: 50%;
            cursor: pointer;
            animation: pulse 1s infinite;
            z-index: 100;
        }

        .hp-potion {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #ff0000);
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .sp-potion {
            background: radial-gradient(circle at 30% 30%, #6b88ff, #0000ff);
            box-shadow: 0 0 10px rgba(0, 0, 255, 0.5);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-30px);
            }
        }

        /* Element Tags */
        .element-tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            color: white;
            font-size: 12px;
            margin-right: 5px;
        }

        /* Stat Buttons */
        .stat-button {
            width: 20px;
            height: 20px;
            margin-left: 5px;
            background: #4a90e2;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            display: none;
        }

        .stat-button:hover {
            background: #357abd;
        }

        /* Experience Bar */
        #expBar {
            width: 100%;
            height: 4px;
            background: #333;
            margin-top: 5px;
            border-radius: 2px;
            overflow: hidden;
        }

        #expFill {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            transition: width 0.3s ease;
        }

        /* Skill Header */
        .skill-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 170%;
            gap: 8px;
        }

        /* Remove Skill Button */
        .remove-skill {
            position: absolute;
            top: -8px;
            right: -8px;
            background: white;
            color: #ff0000;
            border: 2px solid #ff0000;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            padding: 0;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            opacity: 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .skill:hover .remove-skill {
            opacity: 1;
        }

        .remove-skill:hover {
            background: #ffeeee;
            color: #ff0000;
            transform: scale(1.1);
        }

        /* Skill Shortcut */
        .skill-shortcut {
            background: rgba(0, 0, 0, 0.2);
            padding: 3px 8px;
            border-radius: 3px;
            margin-left: 8px;
            font-size: 0.9em;
            cursor: pointer;
            transition: background 0.2s;
        }

        .skill-shortcut:hover {
            background: rgba(0, 0, 0, 0.4);
        }

        .skill-shortcut.listening {
            animation: pulse 1s infinite;
            background: rgba(0, 255, 0, 0.2);
        }

        /* Key Bind */
        .key-bind {
            position: absolute;
            top: -15px;
            right: -5px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            border: 1px solid #666;
        }

        .listening-for-key {
            animation: pulse 1s infinite;
            border: 2px solid #00ff00;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(0, 255, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0); }
        }

        /* Rebind Tooltip */
        .rebind-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            border: 1px solid #666;
            display: none;
        }

        /* Shortcut Tooltip */
        .shortcut-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 1000;
            border: 1px solid #666;
            pointer-events: none;
            display: none;
        }

        /* Warning Message */
        .warning-message {
            position: fixed;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 1000;
            border: 1px solid #ff6666;
            animation: fadeOut 2s forwards;
            pointer-events: none;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* AI Loading */
        .ai-loading {
            color: #fff;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            display: none;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
        }

        /* AI Error */
        .ai-error {
            color: #ff4444;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            display: none;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
        }

        /* Floating Text */
        .floating-text {
            position: absolute;
            animation: floatUp 2s forwards;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        /* Level Up */
        .level-up {
            color: #FFD700;
            font-size: 24px;
            text-shadow: 
                0 0 5px #FFA500,
                0 0 10px #FF8C00,
                0 0 15px #FF7F50;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px);
                opacity: 0;
            }
        }

        /* AI Attack */
        .ai-attack {
            border-radius: 50%;
            animation: pulse 0.5s infinite;
        }

        /* AI Skill */
        .ai-skill {
            animation: rotate 1s infinite linear;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Save/Load Panel */
        .save-load-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 8px;
            color: white;
            z-index: 1000;
            display: none;
        }

        /* Save Slot */
        .save-slot {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .save-slot button {
            margin-left: 10px;
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .save-slot button.save {
            background: #4CAF50;
            color: white;
        }

        .save-slot button.load {
            background: #2196F3;
            color: white;
        }

        .save-slot button.delete {
            background: #f44336;
            color: white;
        }

        /* Close Panel */
        .close-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }

        /* Game Buttons */
        .game-buttons {
            position: absolute;
            top: calc(var(--game-height) * 0.15);  /* Change this line to adjust vertical position */
            right: calc(var(--game-width) * 0.1);  /* Change this line to adjust horizontal position */
            display: flex;
            flex-direction: row;
            gap: 10px;
        }

        /* Control Buttons and Dropdown */
        .game-controls button,
        #dummyElement {
            padding: 8px 16px;
            width: calc(var(--game-width) * 0.12);  /* Match skillInput width */
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 4px;
            color: white;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
        }

        .game-controls button:hover,
        #dummyElement:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: #666;
        }

        #dummyElement {
            margin-top: 5px;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
            padding-right: 30px;
        }

        #dummyElement option {
            background: rgba(0, 0, 0, 0.9);
            color: white;
        }

        /* AI Status Indicators */
        .ai-status-container {
            position: absolute;
            top: calc(var(--game-height) * 0.2 - 110px);  /* Below the game controls */
            right: calc(var(--game-width) * 0.43);
            width: calc(var(--game-width) * 0.25);
            z-index: 100;
        }

        .ai-loading {
            color: #fff;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            display: none;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
        }

        .ai-error {
            color: #ff4444;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            display: none;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
        }

        .skill-description .element-description {
            color: #b8b8b8;
            font-size: 12px;
            margin: 6px 0 10px 0;
            padding: 0 6px;
            font-style: italic;
        }

        .skill-description .element {
            font-weight: 500;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
        }

        .skill-description .stats {
            color: #b8b8b8;
            font-size: 12px;
            margin: 8px 0;
            padding: 8px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .skill-description .skill-lore {
            color: #e0e0e0;
            font-size: 13px;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            line-height: 1.5;
            font-style: italic;
            border-left: 2px solid rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div id="gameArea">
        <div id="statsPanel">
            <div>Level: <span id="levelDisplay">1</span></div>
            <div>Stat Points: <span id="statPoints">0</span></div>
            <div id="expBar"><div id="expFill"></div></div>
            <div class="stat-row">
                STR: <span id="strStat">1</span><button class="stat-button" onclick="addStat('str')">+</button>
            </div>
            <div class="stat-row">
                AGI: <span id="agiStat">1</span><button class="stat-button" onclick="addStat('agi')">+</button>
            </div>
            <div class="stat-row">
                DEX: <span id="dexStat">1</span><button class="stat-button" onclick="addStat('dex')">+</button>
            </div>
            <div class="stat-row">
                INT: <span id="intStat">1</span><button class="stat-button" onclick="addStat('int')">+</button>
            </div>
            <div class="stat-row">
                VIT: <span id="vitStat">1</span><button class="stat-button" onclick="addStat('vit')">+</button>
            </div>
            <div class="stat-row">
                LUK: <span id="lukStat">1</span><button class="stat-button" onclick="addStat('luk')">+</button>
            </div>
        </div>
        <div id="hpSpBar">
            <div>HP: <span id="hpDisplay">100/100</span></div>
            <div class="bar" id="hpBar"><div id="hpFill"></div></div>
            <div>SP: <span id="spDisplay">50/50</span></div>
            <div class="bar" id="spBar"><div id="spFill"></div></div>
        </div>
        <div id="character"></div>
        <div id="rangedBall"></div>
        <div id="dummy">100</div>
    </div>
    <input type="text" id="skillInput" placeholder="Type a skill (e.g., 'shoot a fire ball')" />
    <div class="game-buttons">
    <button onclick="createSkill()">Summon Skill</button>
    <button onclick="resetDummy()">Reset Dummy</button>
        <button onclick="toggleSaveLoadPanel()">Save/Load Skills</button>
    </div>
    <div id="skillList"></div>
    <div class="save-load-panel" id="saveLoadPanel">
        <button class="close-panel" onclick="toggleSaveLoadPanel()">✕</button>
        <h2>Save/Load Skills</h2>
        <div id="saveSlots"></div>
    </div>

    <script>
        // Game area dimensions (matching CSS variables)
        const GAME_WIDTH = 1366;
        const GAME_HEIGHT = 768;
        
        // Entity sizes (matching CSS variables)
        const CHARACTER_SIZE = 50;
        const PROJECTILE_SIZE = 20;

        const character = document.getElementById('character');
        const rangedBall = document.getElementById('rangedBall');
        const dummy = document.getElementById('dummy');
        const skillInput = document.getElementById('skillInput');
        const skillList = document.getElementById('skillList');
        let charX = 275;
        let charY = 175;
        let dummyHealth = 100;
        let skills = [];

        // RPG System Variables
        let playerStats = {
            level: 1,
            exp: 0,
            statPoints: 3,  // Changed from 0 to 3
            str: 1,
            agi: 1,
            dex: 1,
            int: 1,
            vit: 1,
            luk: 1,
            hp: 200,
            maxHp: 200,
            sp: 50,
            maxSp: 50,
            skillCooldown: false,
            lastSpRegen: Date.now()
        };

        // Element system
        const elements = {
            neutral: { 
                name: "Neutral", 
                color: "gray", 
                strongAgainst: [], 
                weakAgainst: [],
                gradient: "linear-gradient(45deg, #808080, #A0A0A0)",
                textColor: "#FFFFFF",
                particleColor: "#C0C0C0",
                description: "Basic non-elemental force"
            },
            fire: { 
                name: "Fire", 
                color: "orange", 
                strongAgainst: ["earth", "undead"], 
                weakAgainst: ["water", "poison"],
                gradient: "linear-gradient(45deg, #FF4500, #FF8C00)",
                textColor: "#FFFFFF",
                particleColor: "#FFD700",
                description: "Burning flames that consume all"
            },
            water: { 
                name: "Water", 
                color: "blue", 
                strongAgainst: ["fire"], 
                weakAgainst: ["wind", "earth"],
                gradient: "linear-gradient(45deg, #00BFFF, #1E90FF)",
                textColor: "#FFFFFF",
                particleColor: "#87CEEB",
                description: "Flowing water that extinguishes flames"
            },
            wind: { 
                name: "Wind", 
                color: "lightgreen", 
                strongAgainst: ["water"], 
                weakAgainst: ["earth", "poison"],
                gradient: "linear-gradient(45deg, #90EE90, #98FB98)",
                textColor: "#000000",
                particleColor: "#F0FFF0",
                description: "Swift winds that cut through water"
            },
            earth: { 
                name: "Earth", 
                color: "brown", 
                strongAgainst: ["wind"], 
                weakAgainst: ["fire"],
                gradient: "linear-gradient(45deg, #8B4513, #A0522D)",
                textColor: "#FFFFFF",
                particleColor: "#DEB887",
                description: "Solid earth that grounds the wind"
            },
            poison: { 
                name: "Poison", 
                color: "purple", 
                strongAgainst: ["neutral"], 
                weakAgainst: ["wind"],
                gradient: "linear-gradient(45deg, #800080, #9400D3)",
                textColor: "#FFFFFF",
                particleColor: "#DA70D6",
                description: "Toxic essence that corrupts life"
            },
            holy: { 
                name: "Holy", 
                color: "yellow", 
                strongAgainst: ["undead", "shadow"], 
                weakAgainst: ["shadow"],
                gradient: "linear-gradient(45deg, #FFD700, #FFFF00)",
                textColor: "#000000",
                particleColor: "#FFFACD",
                description: "Divine light that banishes darkness"
            },
            shadow: { 
                name: "Shadow", 
                color: "darkviolet", 
                strongAgainst: ["holy"], 
                weakAgainst: ["holy"],
                gradient: "linear-gradient(45deg, #483D8B, #4B0082)",
                textColor: "#FFFFFF",
                particleColor: "#9370DB",
                description: "Dark forces that corrupt light"
            },
            undead: { 
                name: "Undead", 
                color: "darkgray", 
                strongAgainst: ["neutral"], 
                weakAgainst: ["fire", "holy"],
                gradient: "linear-gradient(45deg, #696969, #808080)",
                textColor: "#FFFFFF",
                particleColor: "#A9A9A9",
                description: "Unholy power that defies life"
            }
        };

        let dummyElement = "neutral";

        // Add element selector for dummy
        function addElementSelector() {
            const selector = document.createElement('select');
            selector.id = 'dummyElement';
            selector.style.marginLeft = '10px';
            for (const [key, value] of Object.entries(elements)) {
                const option = document.createElement('option');
                option.value = key;
                option.text = value.name;
                selector.appendChild(option);
            }
            selector.onchange = (e) => {
                dummyElement = e.target.value;
                dummy.style.background = elements[dummyElement].color;
            };
            const resetButton = document.querySelector('button[onclick="resetDummy()"]');
            resetButton.parentNode.insertBefore(selector, resetButton.nextSibling);
        }

        // Calculate elemental damage modifier
        function calculateElementalModifier(attackElement, targetElement) {
            // Status effect elements have reduced base damage
            const isStatusElement = ['fire', 'water', 'poison'].includes(attackElement);
            
            // Same element penalty (25% reduction)
            if (attackElement === targetElement) {
                return 0.75;
            }

            // Element advantages based on Ragnarok Online system
            const elementAdvantages = {
                fire: { water: 0.5, earth: 1.5, undead: 1.5, poison: 0.5 },
                water: { fire: 1.5, wind: 0.5, earth: 0.5 },
                wind: { water: 1.5, earth: 0.5, poison: 0.5 },
                earth: { wind: 1.5, fire: 0.5, poison: 0.5 },
                poison: { earth: 1.5, wind: 1.5, fire: 1.5 },
                holy: { undead: 2.0, shadow: 1.25, demon: 1.5 },
                shadow: { holy: 1.25, ghost: 1.5 },
                undead: { fire: 0.5, poison: 0.5, holy: 0.5 },
                neutral: {} // Neutral has no advantages or disadvantages
            };

            // Check if there's an advantage defined
            if (elementAdvantages[attackElement]?.[targetElement]) {
                // For status elements, only apply full damage against advantageous elements
                return isStatusElement ? 
                    elementAdvantages[attackElement][targetElement] : 
                    elementAdvantages[attackElement][targetElement];
            }

            // Default case - apply 30% base damage for status elements against non-advantageous targets
            return isStatusElement ? 0.3 : 1.0;
        }

        // Experience needed for each level (Ragnarok Online-like progression)
        function expForLevel(level) {
            if (level <= 1) return 0;
            if (level > 25) return Infinity; // Prevent leveling past 25
            return Math.floor(Math.pow(level - 1, 3) + 100);
        }

        // Update all displays
        function updateDisplays() {
            document.getElementById('levelDisplay').textContent = playerStats.level;
            document.getElementById('statPoints').textContent = playerStats.statPoints;
            document.getElementById('strStat').textContent = playerStats.str;
            document.getElementById('agiStat').textContent = playerStats.agi;
            document.getElementById('dexStat').textContent = playerStats.dex;
            document.getElementById('intStat').textContent = playerStats.int;
            document.getElementById('vitStat').textContent = playerStats.vit;
            document.getElementById('lukStat').textContent = playerStats.luk;
            
            // Update HP/SP displays with SP rounded to 3 decimal places
            document.getElementById('hpDisplay').textContent = `${playerStats.hp}/${playerStats.maxHp}`;
            document.getElementById('spDisplay').textContent = `${playerStats.sp.toFixed(3)}/${playerStats.maxSp}`;
            document.getElementById('hpFill').style.width = `${(playerStats.hp / playerStats.maxHp) * 100}%`;
            document.getElementById('spFill').style.width = `${(playerStats.sp / playerStats.maxSp) * 100}%`;
            
            // Update exp bar
            const expNeeded = expForLevel(playerStats.level + 1) - expForLevel(playerStats.level);
            const currentExp = playerStats.exp - expForLevel(playerStats.level);
            const expPercentage = (currentExp / expNeeded) * 100;
            document.getElementById('expFill').style.width = `${expPercentage}%`;

            // Show/hide stat buttons
            const buttons = document.getElementsByClassName('stat-button');
            for (let button of buttons) {
                button.style.display = playerStats.statPoints > 0 ? 'inline' : 'none';
            }
        }

        // Add stat point
        function addStat(stat) {
            if (playerStats.statPoints > 0 && playerStats[stat] < 50) {  // Cap at 50
                playerStats[stat]++;
                playerStats.statPoints--;
                
                // Update derived stats
                if (stat === 'vit') {
                    // Each point of VIT gives 50 HP (increased from 20)
                    playerStats.maxHp = 200 + (playerStats.vit * 50);
                    playerStats.hp = playerStats.maxHp;
                }
                if (stat === 'int') {
                    const oldMaxSp = playerStats.maxSp;
                    // INT scaling: Each point gives 8% increase (400% at 50 points)
                    playerStats.maxSp = 50 * (1 + (playerStats.int * 0.08));
                    // Keep the same percentage of SP when maxSp increases
                    playerStats.sp = Math.min(playerStats.sp, playerStats.maxSp);
                }
                
                updateDisplays();
            }
        }

        // Gain experience and handle level up
        function gainExp(amount) {
            playerStats.exp += amount;
            while (playerStats.exp >= expForLevel(playerStats.level + 1)) {
                playerStats.level++;
                playerStats.statPoints += 3; // 3 stat points per level
                // Restore HP/SP on level up
                playerStats.hp = playerStats.maxHp;
                playerStats.sp = playerStats.maxSp;

                // Show floating level up text
                const levelUpText = document.createElement('div');
                levelUpText.className = 'floating-text level-up';
                levelUpText.textContent = `Level Up! ${playerStats.level}`;
                levelUpText.style.position = 'absolute';
                levelUpText.style.left = `${character.offsetLeft + character.offsetWidth / 2}px`;
                levelUpText.style.top = `${character.offsetTop - 20}px`;
                document.getElementById('gameArea').appendChild(levelUpText);

                // Remove the text after animation
                setTimeout(() => {
                    levelUpText.remove();
                }, 2000);
            }
            updateDisplays();
        }

        // Unified status effect system
        const statusEffects = {
            burn: {
                name: 'Burn',
                duration: 5000,
                tickInterval: 500,
                damagePerTick: (source) => {
                    // 10% of STR per tick, source is either 'player' or 'ai'
                    if (source === 'player') {
                        return Math.max(1, Math.floor(playerStats.str * 0.1));
                    } else {
                        // AI burn damage is fixed at 1 for balance
                        return 1;
                    }
                },
                color: '#ff4444',
                particle: '🔥',
                chance: 0.35,
                damageAmplifier: 1.5,
                onApply: (target) => {
                    target.style.filter = 'brightness(1.2) sepia(0.5)';
                },
                onRemove: (target) => {
                    target.style.filter = '';
                }
            },
            poison: {
                name: 'Poison',
                duration: 8000,
                tickInterval: 1000,
                damagePerTick: 3,
                color: '#8b008b',
                particle: '☠️',
                chance: 0.4,
                speedReduction: 0.5,
                onApply: (target) => {
                    target.style.filter = 'brightness(0.8) sepia(0.3) hue-rotate(270deg)';
                },
                onRemove: (target) => {
                    target.style.filter = '';
                }
            },
            freeze: {
                name: 'Freeze',
                duration: 2000,
                color: '#87CEEB',
                particle: '❄️',
                chance: 0.3,
                onApply: (target) => {
                    target.style.filter = 'brightness(1.5) saturate(2) hue-rotate(180deg)';
                },
                onRemove: (target) => {
                    target.style.filter = '';
                }
            }
        };

        // Track status effects for both player and AI
        const entityStatus = {
            player: {
                activeEffects: [],
                baseSpeed: 5,
                currentSpeed: 5,
                isFrozen: false
            },
            ai: {
                activeEffects: [],
                baseSpeed: 3,
                currentSpeed: 3,
                isFrozen: false
            }
        };

        function applyStatusEffect(type, element, target) {
            const effect = statusEffects[type];
            const entity = target === 'player' ? entityStatus.player : entityStatus.ai;
            const targetElement = target === 'player' ? character : dummy;
            
            // Check if effect should be applied based on chance
            if (Math.random() >= effect.chance) return;
            
            // Remove existing effect of the same type
            entity.activeEffects = entity.activeEffects.filter(e => e.type !== type);
            
            // Create new effect instance
            const newEffect = {
                type: type,
                endTime: Date.now() + effect.duration,
                lastTickTime: Date.now()
            };
            
            // Add effect to active effects
            entity.activeEffects.push(newEffect);
            
            // Apply visual effect
            effect.onApply(targetElement);
            
            // Show status effect text
            const statusText = document.createElement('div');
            statusText.className = 'combat-text';
            statusText.style.position = 'absolute';
            statusText.style.left = targetElement.style.left;
            statusText.style.top = (parseInt(targetElement.style.top) - 20) + 'px';
            statusText.style.color = effect.color;
            statusText.style.fontSize = '24px';
            statusText.textContent = effect.particle + ' ' + effect.name;
            document.getElementById('gameArea').appendChild(statusText);
            setTimeout(() => statusText.remove(), 1500);
            
            // Handle freeze effect
            if (type === 'freeze') {
                entity.isFrozen = true;
                setTimeout(() => {
                    entity.isFrozen = false;
                    effect.onRemove(targetElement);
                    entity.activeEffects = entity.activeEffects.filter(e => e.type !== 'freeze');
                }, effect.duration);
            }
            
            // Handle poison effect
            if (type === 'poison') {
                entity.currentSpeed = entity.baseSpeed * (1 - effect.speedReduction);
                setTimeout(() => {
                    entity.currentSpeed = entity.baseSpeed;
                }, effect.duration);
            }
        }

        // Process status effects for both entities
        setInterval(() => {
            const now = Date.now();
            
            // Process player status effects
            processEntityStatusEffects('player', now);
            
            // Process AI status effects
            processEntityStatusEffects('ai', now);
        }, 100);

        function processEntityStatusEffects(entityType, now) {
            const entity = entityStatus[entityType];
            const targetElement = entityType === 'player' ? character : dummy;
            let statusChanged = false;

            entity.activeEffects = entity.activeEffects.filter(effect => {
                const effectData = statusEffects[effect.type];
                
                // Remove expired effects
                if (effect.endTime <= now) {
                    effectData.onRemove(targetElement);
                    statusChanged = true;
                    return false;
                }

                // Process damage over time effects
                if ((effect.type === 'burn' || effect.type === 'poison') && 
                    now - effect.lastTickTime >= effectData.tickInterval) {
                    
                    // Get damage value, handling both function and static values
                    const damage = typeof effectData.damagePerTick === 'function' ? 
                        effectData.damagePerTick(entityType === 'player' ? 'ai' : 'player') : 
                        effectData.damagePerTick;

                    if (entityType === 'player') {
                        damagePlayer(damage);
                    } else {
                        dummyHealth = Math.max(0, dummyHealth - damage);
                        dummy.textContent = dummyHealth;
                        if (dummyHealth <= 0) {
                            dummyHealth = 0;
                            dummy.textContent = dummyHealth;
                            gainExp(50);
                            // Auto-reset after a short delay
                            setTimeout(resetDummy, 1500);
                            return false;
                        }
                    }

                    // Show damage text
                    const damageText = document.createElement('div');
                    damageText.className = 'combat-text';
                    damageText.style.position = 'absolute';
                    damageText.style.left = targetElement.style.left;
                    damageText.style.top = (parseInt(targetElement.style.top) - 20) + 'px';
                    damageText.style.color = effectData.color;
                    damageText.textContent = damage;
                    document.getElementById('gameArea').appendChild(damageText);
                    setTimeout(() => damageText.remove(), 1000);

                    effect.lastTickTime = now;
                }

                return true;
            });
        }

        // Update movement checks to use the unified system
        function updateCharacterPosition() {
            if (isPlayerDead || entityStatus.player.isFrozen) return;
            
            let dx = 0;
            let dy = 0;

            if (pressedKeys.has('w')) dy -= 1;
            if (pressedKeys.has('s')) dy += 1;
            if (pressedKeys.has('a')) dx -= 1;
            if (pressedKeys.has('d')) dx += 1;

            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }

            const newX = charX + dx * entityStatus.player.currentSpeed;
            const newY = charY + dy * entityStatus.player.currentSpeed;

            if (newX >= 0 && newX <= GAME_WIDTH - CHARACTER_SIZE) charX = newX;
            if (newY >= 0 && newY <= GAME_HEIGHT - CHARACTER_SIZE) charY = newY;

            character.style.left = charX + 'px';
            character.style.top = charY + 'px';
        }

        // Update AI movement to use the unified system
        function updateAI() {
            if (isPlayerDead) return;

            const now = Date.now();
            updateAiSp();

            // Don't move if frozen
            if (entityStatus.ai.isFrozen) {
                dummy.style.left = Math.round(aiState.x) + 'px';
                dummy.style.top = Math.round(aiState.y) + 'px';
                return;
            }

            // Rest of AI movement code...
            aiState.moveSpeed = entityStatus.ai.currentSpeed;
            // ... existing AI movement code ...
        }

        // Add dodge system
        let isDodging = false;
        let dodgeEndTime = 0;
        const TELEPORT_DISTANCE = 100; // Distance in pixels for teleport

        // Add dodge effect to character
        function applyDodgeEffect(isTeleport = false) {
            if (isTeleport) {
                character.style.opacity = '0.3';
                character.style.filter = 'blur(4px) brightness(1.5)';
                character.style.transition = 'all 0.2s ease-out';
            } else {
                character.style.opacity = '0.5';
                character.style.filter = 'blur(2px)';
            }
            character.style.animation = 'none';
            isDodging = true;
            dodgeEndTime = Date.now() + 1000; // Set dodge end time
        }

        // Remove dodge effect
        function removeDodgeEffect() {
            character.style.opacity = '1';
            character.style.filter = 'none';
            character.style.transition = '';
            isDodging = false;
        }

        // Handle teleport dodge in specific direction
        function handleTeleportDodge() {
            let dx = 0;
            let dy = 0;

            if (pressedKeys.has('w')) dy -= 1;
            if (pressedKeys.has('s')) dy += 1;
            if (pressedKeys.has('a')) dx -= 1;
            if (pressedKeys.has('d')) dx += 1;

            // If no direction pressed, teleport forward (right)
            if (dx === 0 && dy === 0) {
                dx = 1;
            }

            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }

            // Calculate new position
            const newX = Math.max(0, Math.min(GAME_WIDTH - CHARACTER_SIZE, charX + dx * TELEPORT_DISTANCE));
            const newY = Math.max(0, Math.min(GAME_HEIGHT - CHARACTER_SIZE, charY + dy * TELEPORT_DISTANCE));

            // Create afterimage effect
            const afterimage = document.createElement('div');
            afterimage.style.position = 'absolute';
            afterimage.style.width = `${CHARACTER_SIZE}px`;
            afterimage.style.height = `${CHARACTER_SIZE}px`;
            afterimage.style.background = 'rgba(0, 0, 255, 0.3)';
            afterimage.style.borderRadius = '50%';
            afterimage.style.left = charX + 'px';
            afterimage.style.top = charY + 'px';
            afterimage.style.animation = 'fadeOut 0.5s forwards';
            document.getElementById('gameArea').appendChild(afterimage);

            // Add fadeOut animation if it doesn't exist
            if (!document.querySelector('#teleportStyle')) {
                const style = document.createElement('style');
                style.id = 'teleportStyle';
                style.textContent = `
                    @keyframes fadeOut {
                        from { opacity: 0.3; transform: scale(1); }
                        to { opacity: 0; transform: scale(0.5); }
                    }
                `;
                document.head.appendChild(style);
            }

            // Teleport to new position
            charX = newX;
            charY = newY;
            character.style.left = charX + 'px';
            character.style.top = charY + 'px';

            // Remove afterimage after animation
            setTimeout(() => afterimage.remove(), 500);
        }

        // Add mouse position tracking
        let mouseX = 0;
        let mouseY = 0;

        document.getElementById('gameArea').addEventListener('mousemove', (event) => {
            const gameArea = document.getElementById('gameArea');
            const rect = gameArea.getBoundingClientRect();
            mouseX = event.clientX - rect.left;
            mouseY = event.clientY - rect.top;
        });

        // Modify createSkillEffect function to use cursor position
        function createSkillEffect(type, color, damage, spCost, element, skillName, isDodgeSkill = false, cooldownMs = 1000) {
            return () => {
                if (isPlayerDead || playerStats.skillCooldown || playerStats.sp < spCost || entityStatus.player.isFrozen) {
                    const errorText = document.createElement('div');
                    errorText.className = 'combat-text';
                    errorText.style.left = (charX + 25) + 'px';
                    errorText.style.top = (charY - 20) + 'px';
                    errorText.style.color = '#ff4444';
                    errorText.style.fontSize = '14px';
                    errorText.textContent = isPlayerDead ? "Cannot use skills while dead!" :
                                         entityStatus.player.isFrozen ? "Cannot use skills while frozen!" :
                                         playerStats.skillCooldown ? "Cooldown!" : "Not enough SP!";
                    document.getElementById('gameArea').appendChild(errorText);
                    setTimeout(() => errorText.remove(), 1500);
                    return;
                }

                // Handle dodge skills separately
                if (isDodgeSkill) {
                    const dodgeDuration = 1000; // 1 second of dodge
                    const isTeleport = skillName.toLowerCase().includes('teleport') || 
                                     skillName.toLowerCase().includes('blink');
                    
                    applyDodgeEffect(isTeleport);
                    dodgeEndTime = Date.now() + dodgeDuration;

                    if (isTeleport) {
                        handleTeleportDodge();
                    }

                    // Show dodge activation text
                    const dodgeText = document.createElement('div');
                    dodgeText.className = 'combat-text';
                    dodgeText.style.position = 'absolute';
                    dodgeText.style.left = (charX + 25) + 'px';
                    dodgeText.style.top = (charY - 40) + 'px';
                    dodgeText.style.color = '#ffffff';
                    dodgeText.style.background = 'rgba(0, 0, 0, 0.7)';
                    dodgeText.style.padding = '4px 8px';
                    dodgeText.style.borderRadius = '4px';
                    dodgeText.style.fontSize = '16px';
                    dodgeText.textContent = isTeleport ? '⚡ Blink!' : '🌟 Dodge!';
                    document.getElementById('gameArea').appendChild(dodgeText);
                    setTimeout(() => dodgeText.remove(), 1000);

                    // Remove dodge effect after duration
                    setTimeout(() => {
                        removeDodgeEffect();
                    }, dodgeDuration);

                    playerStats.sp -= spCost;
                    updateDisplays();

                    // Show skill name
                    const skillNameText = document.createElement('div');
                    skillNameText.className = 'combat-text';
                    skillNameText.style.position = 'absolute';
                    skillNameText.style.left = (charX + 25) + 'px';
                    skillNameText.style.top = (charY - 60) + 'px';
                    skillNameText.style.background = elements[element].gradient;
                    skillNameText.style.color = elements[element].textColor;
                    skillNameText.style.padding = '4px 8px';
                    skillNameText.style.borderRadius = '4px';
                    skillNameText.style.fontWeight = 'bold';
                    skillNameText.style.fontSize = '16px';
                    skillNameText.textContent = skillName;
                    document.getElementById('gameArea').appendChild(skillNameText);
                    setTimeout(() => skillNameText.remove(), 1500);

                    // Use AI-determined cooldown
                    playerStats.skillCooldown = true;
                    setTimeout(() => {
                        playerStats.skillCooldown = false;
                    }, cooldownMs);

                    return;
                }

                // Calculate damage bonuses
                let damageMultiplier = 1.0;
                
                // Apply STR bonus for all attacks (4% per point, max 200% at 50 STR)
                damageMultiplier *= (1 + Math.min(2.0, playerStats.str * 0.04));
                
                // Apply LUK critical hit chance (2% per point, max 100% at 50 LUK)
                const lukBonus = Math.random() < Math.min(1.0, playerStats.luk * 0.02);
                
                // Calculate elemental modifier
                const elementalMod = calculateElementalModifier(element, dummyElement);
                
                // Check if target is burned (20% more damage to burned targets)
                const burnVulnerability = entityStatus.ai.activeEffects.some(effect => effect.type === 'burn') ? 1.2 : 1.0;
                
                // Apply burn amplifier only for fire damage
                const burnAmplifier = element === 'fire' && entityStatus.player.activeEffects.some(effect => effect.type === 'burn') 
                    ? statusEffects.burn.damageAmplifier 
                    : 1;
                
                // Calculate final damage
                const finalDamage = Math.floor(
                    damage * damageMultiplier * (lukBonus ? 2 : 1) * elementalMod * burnAmplifier * burnVulnerability * (type === 'melee' ? 2 : 1)
                );

                playerStats.sp -= spCost;
                updateDisplays();

                // Show skill name above player when skill is used
                const skillNameText = document.createElement('div');
                skillNameText.className = 'combat-text';
                skillNameText.style.position = 'absolute';
                skillNameText.style.left = (charX + 25) + 'px';
                skillNameText.style.top = (charY - 40) + 'px';
                skillNameText.style.background = elements[element].gradient;
                skillNameText.style.color = elements[element].textColor;
                skillNameText.style.padding = '4px 8px';
                skillNameText.style.borderRadius = '4px';
                skillNameText.style.fontWeight = 'bold';
                skillNameText.style.fontSize = '16px';
                skillNameText.textContent = skillName;
                document.getElementById('gameArea').appendChild(skillNameText);
                setTimeout(() => skillNameText.remove(), 1500);

                // Use AI-determined cooldown
                playerStats.skillCooldown = true;
                setTimeout(() => {
                    playerStats.skillCooldown = false;
                }, cooldownMs);

                if (type === 'ranged') {
                    // Scale projectile size with DEX (reduced from 2 to 1 per point)
                    const ballSize = 20 + (playerStats.dex * 1);
                    // Scale projectile speed with DEX (reduced from 0.5 to 0.3 per point)
                    const projectileSpeed = 8 + (playerStats.dex * 0.3);
                    
                    // Create a new projectile for this shot
                    const projectile = document.createElement('div');
                    projectile.className = 'projectile';
                    projectile.style.width = `${ballSize}px`;
                    projectile.style.height = `${ballSize}px`;
                    projectile.style.background = elements[element].gradient;
                    projectile.style.boxShadow = `0 0 10px ${elements[element].particleColor}`;
                    projectile.style.position = 'absolute';
                    projectile.style.borderRadius = '50%';
                    projectile.style.zIndex = '100';
                    
                    // Start from character center
                    let ballX = charX + 25;
                    let ballY = charY + 25;
                    projectile.style.left = ballX + 'px';
                    projectile.style.top = ballY + 'px';
                    
                    // Add to game area
                    document.getElementById('gameArea').appendChild(projectile);

                    // Calculate direction to mouse cursor
                    const dx = mouseX - ballX;
                    const dy = mouseY - ballY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const normalizedDx = dx / distance;
                    const normalizedDy = dy / distance;

                    const moveBall = setInterval(() => {
                        ballX += normalizedDx * projectileSpeed;
                        ballY += normalizedDy * projectileSpeed;

                        // Check if ball hits dummy (using AI's current position)
                        const distance = Math.sqrt(
                            Math.pow(ballX - aiState.x, 2) + 
                            Math.pow(ballY - aiState.y, 2)
                        );

                        // Scale hit detection with ball size
                        const hitRadius = ballSize / 2;
                        if (distance < 50 + hitRadius) {
                            dummyHealth -= finalDamage;
                            if (dummyHealth <= 0) {
                                dummyHealth = 0;
                                dummy.textContent = dummyHealth;
                                gainExp(50);
                                // Auto-reset after a short delay
                                setTimeout(resetDummy, 1500);
                            } else {
                                dummy.textContent = dummyHealth;
                            }
                            if (dummyHealth === 0) {
                                gainExp(50);
                            }

                            // Apply status effects on hit
                            if (element === 'fire') {
                                applyStatusEffect('burn', element, 'ai');
                            } else if (element === 'poison') {
                                applyStatusEffect('poison', element, 'ai');
                            } else if (element === 'water') {
                                applyStatusEffect('freeze', element, 'ai');
                            }

                            // Show damage text at AI's current position
                            const damageText = document.createElement('div');
                            damageText.className = 'combat-text';
                            damageText.style.position = 'absolute';
                            damageText.style.left = `${aiState.x}px`;
                            damageText.style.top = `${aiState.y - 20}px`;
                            damageText.style.background = elements[element].gradient;
                            damageText.style.color = elements[element].textColor;
                            damageText.style.padding = '4px 8px';
                            damageText.style.borderRadius = '4px';
                            damageText.style.fontWeight = 'bold';
                            damageText.style.fontSize = '20px';
                            damageText.textContent = finalDamage + (lukBonus ? ' CRIT!' : '');
                            document.getElementById('gameArea').appendChild(damageText);
                            setTimeout(() => damageText.remove(), 1500);

                            clearInterval(moveBall);
                            projectile.remove();  // Remove this projectile
                        } else if (ballX < 0 || ballX > GAME_WIDTH || ballY < 0 || ballY > GAME_HEIGHT) {
                            // Show "Miss!" text if projectile goes off screen
                            const missText = document.createElement('div');
                            missText.className = 'combat-text';
                            missText.style.left = `${ballX}px`;
                            missText.style.top = `${ballY}px`;
                            missText.style.color = '#ff4444';
                            missText.style.fontSize = '14px';
                            missText.textContent = "Miss!";
                            document.getElementById('gameArea').appendChild(missText);
                            setTimeout(() => missText.remove(), 1500);

                            clearInterval(moveBall);
                            projectile.remove();  // Remove this projectile
                        } else {
                            projectile.style.left = ballX + 'px';
                            projectile.style.top = ballY + 'px';
                        }
                    }, 16);
                } else {
                    // For melee attacks, use player position for hit detection
                    character.style.background = elements[element].gradient;
                    character.style.boxShadow = `0 0 10px ${elements[element].particleColor}`;
                    
                    // Calculate distance between player and enemy
                    const distance = Math.sqrt(
                        Math.pow((charX + CHARACTER_SIZE/2) - (aiState.x + CHARACTER_SIZE/2), 2) + 
                        Math.pow((charY + CHARACTER_SIZE/2) - (aiState.y + CHARACTER_SIZE/2), 2)
                    );
                    
                    // Only deal damage if within melee range (70 pixels)
                    if (distance <= 70) {
                        dummyHealth -= finalDamage;
                        if (dummyHealth <= 0) {
                            dummyHealth = 0;
                            dummy.textContent = dummyHealth;
                            gainExp(50);
                            // Auto-reset after a short delay
                            setTimeout(resetDummy, 1500);
                        } else {
                            dummy.textContent = dummyHealth;
                        }
                        if (dummyHealth === 0) {
                            gainExp(50);
                        }

                        // Apply status effects only on hit for melee attacks
                        if (element === 'fire') {
                            applyStatusEffect('burn', element, 'ai');
                        } else if (element === 'poison') {
                            applyStatusEffect('poison', element, 'ai');
                        } else if (element === 'water') {
                            applyStatusEffect('freeze', element, 'ai');
                        }
                        
                        // Show damage text at AI's current position
                        const damageText = document.createElement('div');
                        damageText.className = 'combat-text';
                        damageText.style.position = 'absolute';
                        damageText.style.left = `${aiState.x}px`;
                        damageText.style.top = `${aiState.y - 20}px`;
                        damageText.style.background = elements[element].gradient;
                        damageText.style.color = elements[element].textColor;
                        damageText.style.padding = '4px 8px';
                        damageText.style.borderRadius = '4px';
                        damageText.style.fontWeight = 'bold';
                        damageText.style.fontSize = '20px';
                        damageText.textContent = finalDamage + (lukBonus ? ' CRIT!' : '');
                        document.getElementById('gameArea').appendChild(damageText);
                        setTimeout(() => damageText.remove(), 1500);
                    } else {
                        // Show "Miss!" message if not in range
                        const missText = document.createElement('div');
                        missText.className = 'combat-text';
                        missText.style.left = (charX + 25) + 'px';
                        missText.style.top = (charY - 20) + 'px';
                        missText.style.color = '#ff4444';
                        missText.style.fontSize = '14px';
                        missText.textContent = "Miss!";
                        document.getElementById('gameArea').appendChild(missText);
                        setTimeout(() => missText.remove(), 1500);
                    }
                    setTimeout(() => {
                        character.style.background = 'blue';
                        character.style.boxShadow = 'none';
                    }, 200);
                }
            };
        }

        // Modified resetDummy to restore some SP
        function resetDummy() {
            dummyHealth = 100;
            dummy.textContent = dummyHealth;
            playerStats.sp = Math.min(playerStats.maxSp, playerStats.sp + 20); // Restore some SP
            
            // Clear any active status effects on AI
            entityStatus.ai.activeEffects = [];
            entityStatus.ai.isFrozen = false;
            entityStatus.ai.currentSpeed = entityStatus.ai.baseSpeed;
            dummy.style.filter = '';  // Reset visual effects
            
            updateDisplays();
        }

        // Track pressed keys for smooth movement
        const pressedKeys = new Set();
        const moveSpeed = 5; // Adjust movement speed

        // Move character based on pressed keys
        function updateCharacterPosition() {
            if (isPlayerDead || entityStatus.player.isFrozen) return; // Don't move if dead or frozen

            // Diagonal movement should not be faster than cardinal movement
            let dx = 0;
            let dy = 0;

            if (pressedKeys.has('w')) dy -= 1;
            if (pressedKeys.has('s')) dy += 1;
            if (pressedKeys.has('a')) dx -= 1;
            if (pressedKeys.has('d')) dx += 1;

            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707; // Math.cos(45 degrees)
                dy *= 0.707; // Math.sin(45 degrees)
            }

            // Update position with boundary checking
            const newX = charX + dx * entityStatus.player.currentSpeed;
            const newY = charY + dy * entityStatus.player.currentSpeed;

            if (newX >= 0 && newX <= GAME_WIDTH - CHARACTER_SIZE) charX = newX;
            if (newY >= 0 && newY <= GAME_HEIGHT - CHARACTER_SIZE) charY = newY;

            character.style.left = charX + 'px';
            character.style.top = charY + 'px';
        }

        // Start movement loop
        const movementLoop = setInterval(updateCharacterPosition, 16); // ~60fps

        // Handle keydown
        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            
            // Only handle WASD if we're not typing in the input field
            if (['w', 'a', 's', 'd'].includes(key) && document.activeElement !== skillInput) {
                pressedKeys.add(key);
                event.preventDefault(); // Prevent scrolling
            }

            // Handle skill shortcuts
            if (isListeningForKey) return; // Don't trigger skills while rebinding
            
            // Find which skill this key is bound to
            Object.keys(keyBindings).forEach(skillKey => {
                const binding = keyBindings[skillKey];
                // Check if the pressed key matches the binding
                // Handle special case for spacebar
                if ((key === binding.key) || (key === ' ' && binding.key === ' ')) {
                    const skillIndex = parseInt(skillKey.replace('skill', '')) - 1;
                    if (skillIndex >= 0 && skillIndex < skills.length) {
                        skills[skillIndex].effect();
                    }
                }
            });
        });

        // Handle keyup
        document.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            if (['w', 'a', 's', 'd'].includes(key)) {
                pressedKeys.delete(key);
            }
        });

        // Clean up movement loop when window loses focus
        window.addEventListener('blur', () => {
            pressedKeys.clear();
        });

        // AI-based skill generation
        async function createSkill() {
            const prompt = skillInput.value.trim();
            if (!prompt) return;

            // Get or create the status container
            let statusContainer = document.querySelector('.ai-status-container');
            if (!statusContainer) {
                statusContainer = document.createElement('div');
                statusContainer.className = 'ai-status-container';
                document.getElementById('gameArea').appendChild(statusContainer);
            }

            // Show loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'ai-loading';
            loadingDiv.textContent = '🤖 AI is generating your skill...';
            statusContainer.appendChild(loadingDiv);
            loadingDiv.style.display = 'block';

            // Create error display
            const errorDiv = document.createElement('div');
            errorDiv.className = 'ai-error';
            statusContainer.appendChild(errorDiv);

            try {
                console.log('Sending prompt to AI:', prompt);
                const response = await fetch('http://localhost:11434/api/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'llama3',
                        prompt: `You are an expert game balance designer specializing in RPG combat systems. Create a balanced skill based on this description: "${prompt}".

                        ANALYZE THE SKILL DESCRIPTION FOR:
                        1. Complexity (simple attack vs. complex combo)
                        2. Range (melee vs. ranged)
                        3. Area of Effect (single target vs. AoE)
                        4. Status Effects (none, burn, poison, freeze)
                        5. Utility (pure damage vs. utility/control)
                        6. Theme and Power Fantasy

                        BALANCE GUIDELINES:
                        1. SP Cost (5-50):
                           - Basic attacks: 5-15 SP
                           - Standard skills: 15-30 SP
                           - Complex/Powerful skills: 30-50 SP
                           - Status effects add +5-10 SP
                           - AoE adds +10-15 SP
                           - Melee skills cost 20% less than ranged
                           
                        2. Cooldown (200-3000ms):
                           - Basic attacks: 200-500ms
                           - Standard skills: 500-1500ms
                           - Ultimate/Powerful: 1500-3000ms
                           - Reduce by 20% for utility skills
                           - Increase by 30% for AoE
                           - Melee skills have 25% lower cooldown
                           
                        3. Damage (5-30):
                           - Melee Basic: 8-15 (Higher risk, higher reward)
                           - Ranged Basic: 5-10 (Safer, lower damage)
                           - Melee Standard: 15-25
                           - Ranged Standard: 10-20
                           - Melee Ultimate: 25-35
                           - Ranged Ultimate: 20-30
                           - Reduce by 30% if has status effects
                           - Reduce by 20% if AoE
                           - Neutral skills deal 50% damage
                           - Melee gets +25% STR scaling

                        4. Power Level:
                           LOW: Basic attacks, simple utility
                           MEDIUM: Standard damage/utility skills
                           HIGH: Ultimate abilities, complex combos

                        5. Risk-Reward Factors:
                           - Melee range is 70 pixels
                           - Ranged has projectile travel time
                           - Melee gets better stat scaling
                           - Melee has lower costs and cooldowns

                        Return ONLY a JSON object with these fields:
                        {
                            "name": "skill name",
                            "type": "melee" or "ranged",
                            "element": "fire", "water", "wind", "poison", or "neutral",
                            "damage": number between 5-35,
                            "spCost": number between 5-50,
                            "cooldownMs": number between 200-3000,
                            "description": "skill description",
                            "powerLevel": "low", "medium", or "high",
                            "hasStatusEffect": boolean,
                            "isAoE": boolean,
                            "utilityValue": number between 0-10
                        }

                        IMPORTANT: Return ONLY the JSON object, no other text.`
                    })
                });

                // Read the streaming response
                const reader = response.body.getReader();
                let fullResponse = '';
                
                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    
                    // Convert the Uint8Array to text
                    const chunk = new TextDecoder().decode(value);
                    try {
                        // Parse the chunk as JSON
                        const jsonChunk = JSON.parse(chunk);
                        if (jsonChunk.response) {
                            fullResponse += jsonChunk.response;
                        }
                    } catch (e) {
                        console.warn('Error parsing chunk:', e);
                        fullResponse += chunk;
                    }
                }

                console.log('Full Response:', fullResponse);
                let skillData;
                let isDodgeSkill = false;

                try {
                    // Look for a JSON object in the response
                    const jsonMatch = fullResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        const jsonStr = jsonMatch[0].replace(/\\n/g, '').replace(/\s+/g, ' ');
                        skillData = JSON.parse(jsonStr);
                        console.log('Parsed Skill Data:', skillData);
                        
                        // Check if it's a dodge skill
                        isDodgeSkill = prompt.toLowerCase().includes('dodge') || 
                                     prompt.toLowerCase().includes('evade') || 
                                     prompt.toLowerCase().includes('blink');

                        // Create the skill
                        const skill = {
                            name: skillData.name,
                            effect: createSkillEffect(
                                skillData.type,
                                skillData.color,
                                // Apply 100% bonus damage for melee skills
                                skillData.type === 'melee' ? skillData.damage * 2 : skillData.damage,
                                skillData.spCost,
                                skillData.element,
                                skillData.name,
                                isDodgeSkill,
                                skillData.cooldownMs
                            ),
                            loreDescript: generateWoWDescription(prompt),
                            description: generateTechnicalDescription({
                                ...skillData,
                                // Also update the damage shown in description
                                damage: skillData.type === 'melee' ? skillData.damage * 2 : skillData.damage,
                                loreDescript: generateWoWDescription(prompt)
                            }, isDodgeSkill),
                            damage: skillData.type === 'melee' ? skillData.damage * 2 : skillData.damage,
                            element: skillData.element,
                            spCost: skillData.spCost,
                            cooldownMs: skillData.cooldownMs,
                            isDodgeSkill: isDodgeSkill,
                            powerLevel: skillData.powerLevel
                        };

                        // Add success feedback
                        console.log('Skill created successfully:', skill);
                        const successDiv = document.createElement('div');
                        successDiv.style.color = '#4CAF50';
                        successDiv.style.marginTop = '5px';
                        successDiv.textContent = '✨ Skill generated successfully!';
                        skillInput.parentNode.insertBefore(successDiv, errorDiv);
                        setTimeout(() => successDiv.remove(), 2000);

                        skills.push(skill);
                        updateSkillList();
                        skillInput.value = '';
                    } else {
                        throw new Error('No JSON found in response');
                    }
                } catch (e) {
                    console.error('AI parsing error:', e);
                    errorDiv.textContent = '⚠️ AI response format error, using fallback system';
                    errorDiv.style.display = 'block';
                    setTimeout(() => errorDiv.style.display = 'none', 3000);
                    
                    // Use the fallback system
                    const text = prompt.toLowerCase();
                    const isDodgeSkill = text.includes('dodge') || text.includes('evade') || text.includes('blink');
                    const isAoE = text.includes('area') || text.includes('aoe') || text.includes('explosion') || text.includes('wave');
                    const hasStatusEffect = text.includes('burn') || text.includes('freeze') || text.includes('poison');
                    const isBasicAttack = text.includes('basic') || text.includes('normal') || text.includes('simple');
                    const isPowerful = text.includes('ultimate') || text.includes('powerful') || text.includes('massive');
                    const isMelee = !text.includes('shoot') && !text.includes('beam') && !text.includes('ball');

                    // Create fallback skill data
                    skillData = {
                        name: prompt.charAt(0).toUpperCase() + prompt.slice(1),
                        type: isMelee ? 'melee' : 'ranged',
                        element: text.includes('fire') ? 'fire' : 
                                text.includes('ice') || text.includes('water') ? 'water' : 
                                text.includes('wind') ? 'wind' : 
                                text.includes('poison') ? 'poison' : 'neutral',
                        damage: isMelee ? 
                            (isBasicAttack ? 8 + Math.floor(Math.random() * 8) : // 8-15
                             isPowerful ? 25 + Math.floor(Math.random() * 11) : // 25-35
                             15 + Math.floor(Math.random() * 11)) : // 15-25
                            (isBasicAttack ? 5 + Math.floor(Math.random() * 6) : // 5-10
                             isPowerful ? 20 + Math.floor(Math.random() * 11) : // 20-30
                             10 + Math.floor(Math.random() * 11)), // 10-20
                        spCost: Math.floor((isBasicAttack ? 5 + Math.random() * 11 : // 5-15
                                          isPowerful ? 30 + Math.random() * 21 : // 30-50
                                          15 + Math.random() * 16) * // 15-30
                                         (isMelee ? 0.8 : 1)), // 20% less for melee
                        cooldownMs: Math.floor((isBasicAttack ? 200 + Math.random() * 301 : // 200-500
                                              isPowerful ? 1500 + Math.random() * 1501 : // 1500-3000
                                              500 + Math.random() * 1001) * // 500-1500
                                             (isMelee ? 0.75 : 1)), // 25% lower for melee
                        description: generateWoWDescription(prompt),
                        powerLevel: isPowerful ? "high" : isBasicAttack ? "low" : "medium",
                        hasStatusEffect: hasStatusEffect,
                        isAoE: isAoE,
                        utilityValue: isDodgeSkill ? 8 : hasStatusEffect ? 5 : 2
                    };

                    // Create the skill using fallback data
                const skill = {
                    name: skillData.name,
                        effect: createSkillEffect(
                            skillData.type,
                            elements[skillData.element].color,
                            skillData.damage,
                            skillData.spCost,
                            skillData.element,
                            skillData.name,
                            isDodgeSkill,
                            skillData.cooldownMs
                        ),
                        loreDescript: generateWoWDescription(prompt),
                        description: generateTechnicalDescription({
                            ...skillData,
                            loreDescript: generateWoWDescription(prompt)
                        }, isDodgeSkill),
                        damage: skillData.damage,
                        element: skillData.element,
                        spCost: skillData.spCost,
                        cooldownMs: skillData.cooldownMs,
                        isDodgeSkill: isDodgeSkill,
                        powerLevel: skillData.powerLevel
                    };

                    skills.push(skill);
                    updateSkillList();
                    skillInput.value = '';
                }
            } catch (error) {
                console.error('Error creating skill:', error);
                errorDiv.textContent = `❌ Error: ${error.message}`;
                errorDiv.style.display = 'block';
                setTimeout(() => errorDiv.style.display = 'none', 3000);
            } finally {
                loadingDiv.remove();
            }
        }

        // Enhanced creative skill description generation
        function generateWoWDescription(prompt) {
            const text = prompt.toLowerCase();
            
            // Extract key characteristics
            const isMelee = !text.includes('shoot') && !text.includes('beam') && !text.includes('ball');
            const isDodge = text.includes('dodge') || text.includes('evade') || text.includes('blink');
            const isUltimate = text.includes('ultimate') || text.includes('powerful') || text.includes('massive');
            
            // Determine element and its characteristics
            const elementMap = {
                fire: {
                    element: 'fire',
                    adjectives: ['blazing', 'infernal', 'scorching', 'searing', 'volcanic'],
                    nouns: ['flames', 'inferno', 'blaze', 'firestorm', 'conflagration'],
                    verbs: ['ignites', 'incinerates', 'immolates', 'scorches', 'burns'],
                    effects: ['reducing them to ash', 'leaving only cinders in your wake', 'melting everything in its path', 'creating a devastating inferno']
                },
                water: {
                    element: 'water',
                    adjectives: ['frozen', 'glacial', 'arctic', 'crystalline', 'frigid'],
                    nouns: ['ice', 'frost', 'blizzard', 'avalanche', 'glacier'],
                    verbs: ['freezes', 'chills', 'crystallizes', 'entombs', 'flash-freezes'],
                    effects: ['encasing them in ice', 'shattering their defenses', 'freezing them to their core', 'creating a field of absolute zero']
                },
                wind: {
                    element: 'wind',
                    adjectives: ['tempestuous', 'storming', 'howling', 'cyclonic', 'turbulent'],
                    nouns: ['gale', 'tempest', 'hurricane', 'storm', 'whirlwind'],
                    verbs: ['slices', 'shreds', 'buffets', 'tears through', 'rends'],
                    effects: ['leaving them scattered to the winds', 'creating a devastating vacuum', 'shredding everything in its path', 'forming a destructive cyclone']
                },
                poison: {
                    element: 'poison',
                    adjectives: ['virulent', 'toxic', 'pestilent', 'corrupting', 'venomous'],
                    nouns: ['toxin', 'venom', 'plague', 'miasma', 'corruption'],
                    verbs: ['corrupts', 'infects', 'poisons', 'contaminates', 'taints'],
                    effects: ['melting their very essence', 'spreading unstoppable decay', 'corrupting their life force', 'leaving only decay in its wake']
                },
                neutral: {
                    element: 'force',
                    adjectives: ['mystical', 'arcane', 'ethereal', 'cosmic', 'primal'],
                    nouns: ['energy', 'force', 'power', 'essence', 'might'],
                    verbs: ['strikes', 'crushes', 'devastates', 'overwhelms', 'annihilates'],
                    effects: ['warping reality itself', 'shattering the laws of nature', 'creating a cascade of raw power', 'bending space and time']
                }
            };

            // Determine element based on skill description
            let elementType = 'neutral';
            for (const element in elementMap) {
                if (text.includes(element)) {
                    elementType = element;
                    break;
                }
            }
            
            const elem = elementMap[elementType];
            
            // Random selection helpers
            const pick = arr => arr[Math.floor(Math.random() * arr.length)];
            
            if (isDodge) {
                const dodgeDescriptions = [
                    `Channel the power of ${pick(elem.nouns)} to ${pick(['phase through reality', 'bend space-time', 'transcend physical bounds', 'defy the laws of nature'])}, becoming momentarily ${pick(['ethereal', 'invulnerable', 'untouchable', 'ghostlike'])} as you ${pick(['dance between dimensions', 'slip through the fabric of reality', 'move with supernatural grace', 'traverse the void itself'])}.`,
                    `Harness ${pick(elem.adjectives)} energy to ${pick(['fold space', 'manipulate reality', 'distort dimensions', 'bend the laws of physics'])}, allowing you to ${pick(['blink through the ethereal plane', 'phase through the material world', 'step between moments in time', 'transcend physical barriers'])} with the grace of a cosmic dancer.`,
                    `Invoke ancient ${elem.element} magic to ${pick(['meld with the shadows', 'become one with the void', 'transcend mortal bounds', 'defy physical laws'])}, granting a moment of perfect ${pick(['transcendence', 'invulnerability', 'ethereality', 'dimensional shift'])} as you ${pick(['weave through reality', 'dance between worlds', 'slip through space-time', 'move like living mist'])}.`
                ];
                return pick(dodgeDescriptions);
            }

            if (isMelee) {
                const meleeDescriptions = [
                    `Unleash a devastating ${pick(elem.adjectives)} assault that ${pick(elem.verbs)} your enemies with ${pick(['unrelenting', 'overwhelming', 'unstoppable', 'devastating'])} force, ${pick(elem.effects)}. Each strike resonates with the power of ${pick(['ancient gods', 'primal forces', 'cosmic might', 'elemental fury'])}.`,
                    `Channel pure ${elem.element} into a ${pick(['devastating', 'cataclysmic', 'earth-shattering', 'reality-warping'])} series of strikes, ${pick(elem.verbs)} your foes as ${pick(['reality warps', 'space distorts', 'time fractures', 'dimensions collapse'])} around you, ${pick(elem.effects)}.`,
                    `Become one with the essence of ${elem.element}, transforming your strikes into ${pick(elem.adjectives)} manifestations of pure destruction that ${pick(elem.verbs)} anything in their path, ${pick(elem.effects)} while ${pick(['reality trembles', 'the air screams', 'space fractures', 'time holds its breath'])}.`
                ];
                return pick(meleeDescriptions);
            } else {
                const rangedDescriptions = [
                    `Conjure a ${pick(elem.adjectives)} manifestation of pure ${elem.element} that ${pick(['spirals', 'weaves', 'tears', 'rips'])} through the fabric of reality, ${pick(elem.verbs)} your enemies as it ${pick(['defies physics', 'warps space', 'bends time', 'shatters dimensions'])}, ${pick(elem.effects)}.`,
                    `Summon forth a ${pick(elem.adjectives)} torrent of ${pick(elem.nouns)} that ${pick(['cascades', 'erupts', 'surges', 'storms'])} across the battlefield, ${pick(elem.verbs)} all who stand before you while ${pick(['reality buckles', 'the air screams', 'space distorts', 'time fragments'])}, ${pick(elem.effects)}.`,
                    `Channel the primal essence of ${elem.element} into a ${pick(elem.adjectives)} projectile that ${pick(['screams', 'howls', 'roars', 'thunders'])} through the air, ${pick(elem.verbs)} your foes as it ${pick(['tears reality asunder', 'shatters the material plane', 'ruptures the fabric of space', 'fractures the bounds of existence'])}, ${pick(elem.effects)}.`
                ];
                return pick(rangedDescriptions);
            }
        }

        // Update technical description to show AI-determined values
        function generateTechnicalDescription(skillData, isDodgeSkill) {
            const element = elements[skillData.element];
            const cooldownSec = (skillData.cooldownMs / 1000).toFixed(1);
            const powerLevelColors = {
                low: '#4CAF50',    // Green
                medium: '#FFA726',  // Orange
                high: '#F44336'     // Red
            };
            
            return `
                <h3>${skillData.name}</h3>
                <div class="element" style="background: ${element.gradient}; color: ${element.textColor}">
                    ${element.name}${isDodgeSkill ? ' • Dodge Skill' : ''}
                </div>
                <div class="element-description" style="color: ${element.color}">
                    📖 ${element.description}
                </div>
                <div class="skill-lore">
                    ${skillData.loreDescript}
                </div>
                <div class="stats">
                    ${isDodgeSkill 
                        ? `<div>✨ Effect: 1 second invulnerability</div>
                           <div>🎯 Dodge Chance: 100%</div>` 
                        : `<div class="damage">💥 Damage: ${skillData.type === 'melee' ? skillData.damage * 2 : skillData.damage}</div>`}
                    <div class="sp-cost">✨ SP Cost: ${skillData.spCost}</div>
                    <div class="cooldown">⏱ Cooldown: ${cooldownSec}s</div>
                    <div>🎯 Type: ${isDodgeSkill ? 'Dodge' : skillData.type.charAt(0).toUpperCase() + skillData.type.slice(1)}</div>
                    <div style="color: ${powerLevelColors[skillData.powerLevel.toLowerCase()]}">
                        ⚡ Power: ${skillData.powerLevel.toUpperCase()}
                    </div>
                </div>
                <div class="element-info">
                    <div>💪 Strong vs: ${element.strongAgainst.length ? element.strongAgainst.map(e => elements[e].name).join(', ') : 'None'}</div>
                    <div>⚠️ Weak vs: ${element.weakAgainst.length ? element.weakAgainst.map(e => elements[e].name).join(', ') : 'None'}</div>
                </div>
            `;
        }

        // Show skills with descriptions
        function updateSkillList() {
            skillList.innerHTML = '';
            skills.forEach((skill, index) => {
                const skillDiv = document.createElement('div');
                skillDiv.className = 'skill';
                
                const skillHeader = document.createElement('div');
                skillHeader.className = 'skill-header';
                
                const button = document.createElement('button');
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = skill.name;
                
                const shortcutSpan = document.createElement('span');
                shortcutSpan.className = 'skill-shortcut';
                const binding = keyBindings[`skill${index + 1}`];
                shortcutSpan.textContent = `[${binding.display}]`;
                
                // Add click handler for shortcut rebinding
                shortcutSpan.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent triggering the skill
                    
                    // Reset any other shortcuts
                    document.querySelectorAll('.skill-shortcut').forEach(s => {
                        s.classList.remove('listening');
                    });
                    
                    // Set up listening state
                    isListeningForKey = true;
                    currentBindingSkill = `skill${index + 1}`;
                    shortcutSpan.classList.add('listening');
                    
                    // Show tooltip near the shortcut
                    const rect = shortcutSpan.getBoundingClientRect();
                    shortcutTooltip.style.display = 'block';
                    shortcutTooltip.style.left = `${rect.left}px`;
                    shortcutTooltip.style.top = `${rect.top - 40}px`;
                    
                    // Add temporary event listener
                    document.addEventListener('keydown', handleKeyBinding);
                    
                    // Cancel listening if clicked elsewhere
                    const cancelListener = (e) => {
                        if (!shortcutSpan.contains(e.target)) {
                            isListeningForKey = false;
                            currentBindingSkill = null;
                            shortcutSpan.classList.remove('listening');
                            shortcutTooltip.style.display = 'none';
                            document.removeEventListener('keydown', handleKeyBinding);
                            document.removeEventListener('click', cancelListener);
                        }
                    };
                    document.addEventListener('click', cancelListener);
                });
                
                button.appendChild(nameSpan);
                button.appendChild(shortcutSpan);
                button.style.background = elements[skill.element].gradient;
                button.style.color = elements[skill.element].textColor;
                button.onclick = skill.effect;
                
                const removeButton = document.createElement('button');
                removeButton.className = 'remove-skill';
                removeButton.textContent = '×';
                removeButton.onclick = (e) => {
                    e.stopPropagation();
                    skillDiv.style.animation = 'fadeOut 0.3s forwards';
                    setTimeout(() => {
                        skills.splice(index, 1);
                        updateSkillList();
                    }, 300);
                };
                
                skillHeader.appendChild(button);
                skillHeader.appendChild(removeButton);
                
                const desc = document.createElement('div');
                desc.className = 'skill-description';
                desc.innerHTML = skill.description;
                
                skillDiv.appendChild(skillHeader);
                skillDiv.appendChild(desc);
                skillList.appendChild(skillDiv);
            });
        }

        // Add SP regeneration function
        function startSpRegeneration() {
            setInterval(() => {
                const now = Date.now();
                const timePassed = now - playerStats.lastSpRegen;
                
                // Base SP regen per second (similar to RO's system)
                const baseRegen = 1;
                // INT bonus: Every 1 INT adds 0.2 SP per second
                const intBonus = (playerStats.int - 1) * 0.2;
                
                // Calculate SP to regenerate based on time passed and round to 3 decimal places
                const regenAmount = ((baseRegen + intBonus) * (timePassed / 1000));
                
                // Add SP and round to 3 decimal places
                playerStats.sp = Math.min(playerStats.maxSp, Math.round((playerStats.sp + regenAmount) * 1000) / 1000);
                playerStats.lastSpRegen = now;
                
                // Update displays
                updateDisplays();
            }, 100); // Update every 100ms for smooth regeneration
        }

        // Initialize displays and start SP regeneration
        updateDisplays();
        startSpRegeneration();

        // Initialize element selector
        addElementSelector();

        // Potion system
        let activePotion = null;
        const POTION_SPAWN_CHANCE = 0.02; // 2% chance per second (increased from 0.5%)
        const POTION_HEAL_AMOUNT = 50;
        const POTION_SP_AMOUNT = 30;

        function spawnPotion() {
            if (activePotion) return; // Only one potion at a time
            
            if (Math.random() < POTION_SPAWN_CHANCE) {
                const potion = document.createElement('div');
                const isHpPotion = Math.random() < 0.3; // 30% chance for HP, 70% for SP
                
                potion.className = `potion ${isHpPotion ? 'hp-potion' : 'sp-potion'}`;
                // Random position within game area bounds
                const x = Math.floor(Math.random() * GAME_WIDTH);
                const y = Math.floor(Math.random() * GAME_HEIGHT);
                
                potion.style.left = x + 'px';
                potion.style.top = y + 'px';
                
                potion.onclick = () => {
                    collectPotion(potion, isHpPotion, x, y);
                };
                
                document.getElementById('gameArea').appendChild(potion);
                activePotion = potion;
                
                // Remove potion after 10 seconds if not collected
                setTimeout(() => {
                    if (activePotion === potion) {
                        if (potion.parentNode) {
                            potion.parentNode.removeChild(potion);
                        }
                        activePotion = null;
                    }
                }, 10000);
            }
        }

        function collectPotion(potion, isHpPotion, x, y) {
            if (isHpPotion) {
                playerStats.hp = Math.min(playerStats.maxHp, playerStats.hp + POTION_HEAL_AMOUNT);
                showPotionEffect(x, y, `+${POTION_HEAL_AMOUNT} HP`, '#ff6b6b');
                // Remove poison effect when HP potion is collected
                entityStatus.player.activeEffects = entityStatus.player.activeEffects.filter(effect => effect.type !== 'poison');
                entityStatus.player.currentSpeed = entityStatus.player.baseSpeed; // Restore normal movement speed
            } else {
                playerStats.sp = Math.min(playerStats.maxSp, playerStats.sp + POTION_SP_AMOUNT);
                showPotionEffect(x, y, `+${POTION_SP_AMOUNT} SP`, '#6b88ff');
            }
            updateDisplays();
            potion.remove();  // Use remove() instead of removeChild
            activePotion = null;
        }

        function showPotionEffect(x, y, text, color) {
            const effect = document.createElement('div');
            effect.className = 'combat-text';
            effect.style.left = x + 'px';
            effect.style.top = y + 'px';
            effect.style.color = color;
            effect.style.fontSize = '16px';
            effect.textContent = text;
            document.getElementById('gameArea').appendChild(effect);
            setTimeout(() => effect.remove(), 1500);
        }

        // Start potion spawn check every second
        setInterval(spawnPotion, 1000);

        // Add after character creation
        let keyBindings = {
            skill1: { key: '1', display: '1' },
            skill2: { key: '2', display: '2' },
            skill3: { key: '3', display: '3' },
            skill4: { key: '4', display: '4' }
        };

        // Add to localStorage initialization with new format
        if (!localStorage.getItem('keyBindings')) {
            localStorage.setItem('keyBindings', JSON.stringify(keyBindings));
        } else {
            keyBindings = JSON.parse(localStorage.getItem('keyBindings'));
        }

        let isListeningForKey = false;
        let currentBindingSkill = null;

        // Create tooltip element
        const shortcutTooltip = document.createElement('div');
        shortcutTooltip.className = 'shortcut-tooltip';
        shortcutTooltip.textContent = 'Click to change shortcut...';
        document.body.appendChild(shortcutTooltip);

        function getKeyDisplay(event) {
            if (event.key === ' ') return 'SPACE';
            if (event.key === 'Meta') return '⌘';
            if (event.key === 'Alt') return 'Alt';
            if (event.key === 'Control') return 'Ctrl';
            if (event.key === 'Shift') return '⇧';
            return event.key.toUpperCase();
        }

        function updateKeyBindDisplay() {
            document.querySelectorAll('.skill-shortcut').forEach((shortcut, index) => {
                const skillNum = index + 1;
                const binding = keyBindings[`skill${skillNum}`];
                shortcut.textContent = `[${binding.display}]`;
            });
        }

        function handleKeyBinding(event) {
            if (!isListeningForKey || !currentBindingSkill) return;
            
            event.preventDefault();
            
            const key = event.key.toLowerCase();
            
            // Check for reserved movement keys
            const reservedKeys = ['w', 'a', 's', 'd'];
            if (reservedKeys.includes(key)) {
                // Show warning message
                const warning = document.createElement('div');
                warning.className = 'warning-message';
                warning.textContent = `Cannot bind movement key "${key.toUpperCase()}"!`;
                warning.style.left = shortcutTooltip.style.left;
                warning.style.top = shortcutTooltip.style.top;
                document.body.appendChild(warning);
                
                // Remove warning after animation
                setTimeout(() => warning.remove(), 2000);
                
                return;
            }
            
            // Get the key display and actual key value
            const display = getKeyDisplay(event);
            
            // Remove old binding
            Object.keys(keyBindings).forEach(skill => {
                if (keyBindings[skill].key === key) {
                    keyBindings[skill] = { key: '', display: '' };
                }
            });
            
            // Set new binding
            keyBindings[currentBindingSkill] = {
                key: key,
                display: display
            };
            
            // Save to localStorage
            localStorage.setItem('keyBindings', JSON.stringify(keyBindings));
            
            // Update displays
            updateKeyBindDisplay();
            
            // Reset listening state
            isListeningForKey = false;
            currentBindingSkill = null;
            document.querySelectorAll('.skill-shortcut').forEach(shortcut => {
                shortcut.classList.remove('listening');
            });
            shortcutTooltip.style.display = 'none';
            
            // Remove the temporary event listener
            document.removeEventListener('keydown', handleKeyBinding);
        }

        // Initialize key bindings display
        document.addEventListener('DOMContentLoaded', () => {
            updateKeyBindDisplay();
        });

        document.addEventListener('keydown', function(event) {
            if (isBindingKey) {
                event.preventDefault();
                
                // Check for WASD and modifier combinations
                const movementKeys = ['w', 'a', 's', 'd'];
                const isMovementKey = movementKeys.includes(event.key.toLowerCase());
                const hasModifier = event.ctrlKey || event.metaKey || event.altKey;

                if (isMovementKey || (hasModifier && isMovementKey)) {
                    const modifierText = hasModifier ? 
                        `${event.ctrlKey ? 'Ctrl+' : ''}${event.metaKey ? 'Cmd+' : ''}${event.altKey ? 'Alt+' : ''}` : '';
                    
                    showWarningMessage(`Cannot bind ${modifierText}${event.key.toUpperCase()} - Reserved for movement!`);
                    return;
                }

                // Get the key display value
                let keyDisplay = event.key;
                if (event.key === ' ') keyDisplay = 'Space';
                if (event.key.length === 1) keyDisplay = event.key.toUpperCase();
                
                // Update the key binding
                const skillId = currentBindingSkill;
                keyBindings[skillId] = {
                    key: event.key,
                    display: keyDisplay
                };
                
                // Update the display and save
                document.querySelector(`[data-skill-id="${skillId}"] .shortcut`).textContent = keyDisplay;
                localStorage.setItem('keyBindings', JSON.stringify(keyBindings));
                
                isBindingKey = false;
                currentBindingSkill = null;
                return;
            }

            // Handle normal key press for skills
            if (!event.ctrlKey && !event.metaKey && !event.altKey) {
                handleSkillKeyPress(event.key);
            }
        });

        // Helper function to show warning message
        function showWarningMessage(message) {
            const warningMessage = document.createElement('div');
            warningMessage.className = 'warning-message';
            warningMessage.textContent = message;
            warningMessage.style.top = '50%';
            warningMessage.style.left = '50%';
            warningMessage.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(warningMessage);
            
            setTimeout(() => {
                warningMessage.remove();
            }, 2000);
        }

        if (playerStats.experience >= playerStats.experienceToNextLevel) {
            playerStats.level++;
            playerStats.experience = 0;
            playerStats.experienceToNextLevel = Math.floor(playerStats.experienceToNextLevel * 1.5);
            
            // Restore HP/SP on level up
            playerStats.hp = playerStats.maxHp;
            playerStats.sp = playerStats.maxSp;

            // Show floating level up text
            const levelUpText = document.createElement('div');
            levelUpText.className = 'floating-text level-up';
            levelUpText.textContent = `Level Up! ${playerStats.level}`;
            levelUpText.style.position = 'absolute';
            levelUpText.style.left = `${character.offsetLeft + character.offsetWidth / 2}px`;
            levelUpText.style.top = `${character.offsetTop - 20}px`;
            document.getElementById('gameArea').appendChild(levelUpText);

            // Remove the text after animation
            setTimeout(() => {
                levelUpText.remove();
            }, 2000);

            updateStats();
        }

        // Add AI properties to the game state
        const aiState = {
            x: 450,
            y: 175,
            targetX: 450,
            targetY: 175,
            moveSpeed: 3,
            attackRange: 100,
            skillCooldown: false,
            lastAttackTime: 0,
            attackCooldown: 2500,
            sp: 50,
            maxSp: 50,
            lastSpRegen: Date.now(),
            isAttacking: false,
            skills: [
                { name: 'Fireball', element: 'fire', type: 'ranged', damage: 15, cooldown: 6000, spCost: 20 },
                { name: 'Ice Shard', element: 'water', type: 'ranged', damage: 12, cooldown: 5000, spCost: 15 },
                { name: 'Poison Cloud', element: 'poison', type: 'ranged', damage: 8, cooldown: 7000, spCost: 25 },
                { name: 'Shadow Blink', element: 'shadow', type: 'dodge', damage: 0, cooldown: 8000, spCost: 30 }
            ],
            lastSkillTime: 0,
            hasTarget: false,
            isBlinking: false
        };

        // Add AI SP regeneration
        function updateAiSp() {
            const now = Date.now();
            const timePassed = now - aiState.lastSpRegen;
            const spRegen = (timePassed / 1000) * 2; // 2 SP per second
            aiState.sp = Math.min(aiState.maxSp, aiState.sp + spRegen);
            aiState.lastSpRegen = now;
        }

        // Update player death check
        function checkPlayerDeath() {
            if (playerStats.hp <= 0 && !document.querySelector('#gameArea > div[style*="rgba(0, 0, 0, 0.7)"]')) {
                playerStats.hp = 0;  // Ensure health is exactly 0
                updateDisplays();
                
                // Create death overlay
                const deathOverlay = document.createElement('div');
                deathOverlay.id = 'deathOverlay';
                deathOverlay.style.position = 'absolute';
                deathOverlay.style.top = '0';
                deathOverlay.style.left = '0';
                deathOverlay.style.width = '100%';
                deathOverlay.style.height = '100%';
                deathOverlay.style.background = 'rgba(0, 0, 0, 0.7)';
                deathOverlay.style.display = 'flex';
                deathOverlay.style.flexDirection = 'column';
                deathOverlay.style.justifyContent = 'center';
                deathOverlay.style.alignItems = 'center';
                deathOverlay.style.color = '#ff4444';
                deathOverlay.style.fontSize = '32px';
                deathOverlay.style.zIndex = '1000';
                deathOverlay.innerHTML = `
                    <div style="text-shadow: 2px 2px 4px #000;">YOU DIED</div>
                    <button onclick="respawnPlayer()" style="
                        margin-top: 20px;
                        padding: 10px 20px;
                        font-size: 18px;
                        background: #ff4444;
                        color: white;
                        border: none;
                        border-radius: 5px;
                        cursor: pointer;
                        box-shadow: 2px 2px 4px rgba(0,0,0,0.5);">
                        Respawn
                    </button>
                `;
                document.getElementById('gameArea').appendChild(deathOverlay);

                // Disable movement and skills
                isPlayerDead = true;
            }
        }

        // Add respawn function
        function respawnPlayer() {
            // Reset player stats
            playerStats.hp = playerStats.maxHp;
            playerStats.sp = playerStats.maxSp;
            isPlayerDead = false;
            
            // Clear all status effects on player
            entityStatus.player.activeEffects = [];
            entityStatus.player.isFrozen = false;
            entityStatus.player.currentSpeed = entityStatus.player.baseSpeed;
            character.style.filter = '';  // Reset visual effects
            
            // Reset position
            charX = 275;
            charY = 175;
            character.style.left = charX + 'px';
            character.style.top = charY + 'px';
            
            // Remove ALL death overlays
            const deathOverlays = document.querySelectorAll('#gameArea > div[style*="rgba(0, 0, 0, 0.7)"]');
            deathOverlays.forEach(overlay => overlay.remove());
            
            // Update displays
            updateDisplays();
        }

        // Update damagePlayer function to check dodge state
        function damagePlayer(amount) {
            if (isDodging) {
                // Show dodge message
                const dodgeText = document.createElement('div');
                dodgeText.className = 'combat-text';
                dodgeText.style.position = 'absolute';
                dodgeText.style.left = (charX + 25) + 'px';
                dodgeText.style.top = (charY - 20) + 'px';
                dodgeText.style.color = '#00ff00';  // Green color for dodge
                dodgeText.style.fontSize = '20px';
                dodgeText.style.fontWeight = 'bold';
                dodgeText.textContent = 'Dodged!';
                document.getElementById('gameArea').appendChild(dodgeText);
                setTimeout(() => dodgeText.remove(), 1000);
                return;
            }
            playerStats.hp = Math.max(0, playerStats.hp - amount);
            checkPlayerDeath();
            updateDisplays();
        }

        // Update AI skill usage to check SP and apply correct damage
        function aiUseSkill(skill, targetX, targetY) {
            if (aiState.sp < skill.spCost || entityStatus.ai.isFrozen) return;
            
            aiState.sp -= skill.spCost;
            
            const projectile = document.createElement('div');
            projectile.className = 'ai-skill';
            projectile.style.position = 'absolute';
            projectile.style.left = aiState.x + 'px';
            projectile.style.top = aiState.y + 'px';
            projectile.style.width = `${PROJECTILE_SIZE}px`;
            projectile.style.height = `${PROJECTILE_SIZE}px`;
            projectile.style.borderRadius = '50%';
            
            // Style based on element
            switch(skill.element) {
                case 'fire':
                    projectile.style.background = 'linear-gradient(45deg, #ff4400, #ff8800)';
                    projectile.style.boxShadow = '0 0 10px #ff4400';
                    break;
                case 'water':
                    projectile.style.background = 'linear-gradient(45deg, #00aaff, #0044ff)';
                    projectile.style.boxShadow = '0 0 10px #00aaff';
                    break;
                case 'poison':
                    projectile.style.background = 'linear-gradient(45deg, #00ff44, #88ff00)';
                    projectile.style.boxShadow = '0 0 10px #00ff44';
                    break;
            }
            
            document.getElementById('gameArea').appendChild(projectile);

            // Animate skill
            const angle = Math.atan2(targetY - aiState.y, targetX - aiState.x);
            const speed = 8;
            const moveSkill = setInterval(() => {
                const x = parseInt(projectile.style.left);
                const y = parseInt(projectile.style.top);
                
                projectile.style.left = (x + Math.cos(angle) * speed) + 'px';
                projectile.style.top = (y + Math.sin(angle) * speed) + 'px';

                // Check if hit player
                const distToPlayer = Math.sqrt(
                    Math.pow(x - targetX, 2) + 
                    Math.pow(y - targetY, 2)
                );

                if (distToPlayer < 30) {
                    if (isDodging) {
                        // Show dodge message
                        const dodgeText = document.createElement('div');
                        dodgeText.className = 'combat-text';
                        dodgeText.style.position = 'absolute';
                        dodgeText.style.left = (charX + 25) + 'px';
                        dodgeText.style.top = (charY - 20) + 'px';
                        dodgeText.style.color = '#00ff00';
                        dodgeText.style.fontSize = '20px';
                        dodgeText.style.fontWeight = 'bold';
                        dodgeText.textContent = 'Dodged!';
                        document.getElementById('gameArea').appendChild(dodgeText);
                        setTimeout(() => dodgeText.remove(), 1000);
                    } else {
                        damagePlayer(skill.damage);
                        // Apply status effects to player
                        if (skill.element === 'fire') {
                            applyStatusEffect('burn', 'fire', 'player');
                        } else if (skill.element === 'poison') {
                            applyStatusEffect('poison', 'poison', 'player');
                        } else if (skill.element === 'water') {
                            applyStatusEffect('freeze', 'water', 'player');
                        }

                        // Show damage text only if not dodging
                        const damageText = document.createElement('div');
                        damageText.className = 'combat-text';
                        damageText.style.position = 'absolute';
                        damageText.style.left = targetX + 'px';
                        damageText.style.top = (targetY - 20) + 'px';
                        damageText.style.color = '#ff4444';
                        damageText.textContent = skill.damage;
                        document.getElementById('gameArea').appendChild(damageText);
                        setTimeout(() => damageText.remove(), 1000);
                    }
                    clearInterval(moveSkill);
                    projectile.remove();
                } else if (x < 0 || x > GAME_WIDTH || y < 0 || y > GAME_HEIGHT) {
                    clearInterval(moveSkill);
                    projectile.remove();
                }
            }, 16);
        }

        // Update AI position and behavior
        function updateAI() {
            if (isPlayerDead) return;

            const now = Date.now();
            updateAiSp();

            // Don't move if frozen
            if (entityStatus.ai.isFrozen) {
                dummy.style.left = Math.round(aiState.x) + 'px';
                dummy.style.top = Math.round(aiState.y) + 'px';
                return;
            }

            // Calculate distance to player
            const distToPlayer = Math.sqrt(
                Math.pow(aiState.x - charX, 2) + 
                Math.pow(aiState.y - charY, 2)
            );

            // AI Combat
            if (distToPlayer < aiState.attackRange && !isPlayerDead) {
                // Basic attack if cooldown is ready
                if (now - aiState.lastAttackTime > aiState.attackCooldown) {
                    aiBasicAttack(charX, charY);
                    aiState.lastAttackTime = now;
                }

                // Use skills if available and has enough SP
                if (now - aiState.lastSkillTime > 5000) {
                    const availableSkills = aiState.skills.filter(skill => 
                        (!skill.lastUseTime || now - skill.lastUseTime > skill.cooldown) &&
                        aiState.sp >= skill.spCost
                    );
                    
                    if (availableSkills.length > 0) {
                        const skill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                        if (skill.type === 'dodge') {
                            aiBlinkSkill();
                        } else {
                            aiUseSkill(skill, charX, charY);
                        }
                        skill.lastUseTime = now;
                        aiState.lastSkillTime = now;
                        aiState.sp -= skill.spCost;
                    }
                }
            }

            // Only update movement if not blinking
            if (!aiState.isBlinking) {
                // ... rest of the existing AI movement code ...
                // AI Movement with improved independence
                if (!aiState.hasTarget || Math.random() < 0.02) {
                    const pattern = Math.random();
                    
                    if (pattern < 0.3) {
                        const circleRadius = 100;
                        const angle = (now / 1000) % (2 * Math.PI);
                        aiState.targetX = 300 + Math.cos(angle) * circleRadius;
                        aiState.targetY = 200 + Math.sin(angle) * circleRadius;
                    } else if (pattern < 0.6) {
                        const radius = 80;
                        const t = (now / 2000) % (2 * Math.PI);
                        aiState.targetX = 300 + radius * Math.cos(t);
                        aiState.targetY = 200 + radius * Math.sin(2 * t) / 2;
                    } else {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 50 + Math.random() * 100;
                        aiState.targetX = aiState.x + Math.cos(angle) * distance;
                        aiState.targetY = aiState.y + Math.sin(angle) * distance;
                    }
                    
                    aiState.hasTarget = true;
                    aiState.patternStartTime = now;
                }

                // Keep AI in bounds with padding
                const padding = 50;
                aiState.targetX = Math.max(padding, Math.min(GAME_WIDTH - padding, aiState.targetX));
                aiState.targetY = Math.max(padding, Math.min(GAME_HEIGHT - padding, aiState.targetY));

                // Smooth movement towards target
                const dx = aiState.targetX - aiState.x;
                const dy = aiState.targetY - aiState.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 1) {
                    aiState.x += (dx / dist) * aiState.moveSpeed;
                    aiState.y += (dy / dist) * aiState.moveSpeed;
                }

                // Apply movement with rounding to prevent sub-pixel jitter
                dummy.style.left = Math.round(aiState.x) + 'px';
                dummy.style.top = Math.round(aiState.y) + 'px';
            }
        }

        // AI basic attack with reduced damage
        function aiBasicAttack(targetX, targetY) {
            if (isPlayerDead || aiState.isAttacking || entityStatus.ai.isFrozen) return;

            aiState.isAttacking = true;
            const damage = Math.floor(Math.random() * 4) + 4; // 4-7 damage
            
            const attackEffect = document.createElement('div');
            attackEffect.className = 'ai-attack';
            attackEffect.style.position = 'absolute';
            attackEffect.style.left = aiState.x + 'px';
            attackEffect.style.top = aiState.y + 'px';
            attackEffect.style.width = '10px';
            attackEffect.style.height = '10px';
            attackEffect.style.background = '#ff4444';
            attackEffect.style.borderRadius = '50%';
            document.getElementById('gameArea').appendChild(attackEffect);

            // Animate attack towards player with reduced speed
            const angle = Math.atan2(targetY - aiState.y, targetX - aiState.x);
            const speed = 8; // Reduced from 15 to 8 for more reasonable speed
            const moveAttack = setInterval(() => {
                const x = parseInt(attackEffect.style.left);
                const y = parseInt(attackEffect.style.top);
                
                attackEffect.style.left = (x + Math.cos(angle) * speed) + 'px';
                attackEffect.style.top = (y + Math.sin(angle) * speed) + 'px';

                // Check if hit player
                const distToPlayer = Math.sqrt(
                    Math.pow(x - targetX, 2) + 
                    Math.pow(y - targetY, 2)
                );

                if (distToPlayer < 30) {
                    if (isDodging) {
                        // Show dodge message
                        const dodgeText = document.createElement('div');
                        dodgeText.className = 'combat-text';
                        dodgeText.style.position = 'absolute';
                        dodgeText.style.left = (charX + 25) + 'px';
                        dodgeText.style.top = (charY - 20) + 'px';
                        dodgeText.style.color = '#00ff00';
                        dodgeText.style.fontSize = '20px';
                        dodgeText.style.fontWeight = 'bold';
                        dodgeText.textContent = 'Dodged!';
                        document.getElementById('gameArea').appendChild(dodgeText);
                        setTimeout(() => dodgeText.remove(), 1000);
                    } else {
                        damagePlayer(damage);
                        // Show damage text only if not dodging
                        const damageText = document.createElement('div');
                        damageText.className = 'combat-text';
                        damageText.style.position = 'absolute';
                        damageText.style.left = targetX + 'px';
                        damageText.style.top = (targetY - 20) + 'px';
                        damageText.style.color = '#ff4444';
                        damageText.textContent = damage;
                        document.getElementById('gameArea').appendChild(damageText);
                        setTimeout(() => damageText.remove(), 1000);
                    }
                    clearInterval(moveAttack);
                    attackEffect.remove();
                    aiState.isAttacking = false;
                } else if (x < 0 || x > GAME_WIDTH || y < 0 || y > GAME_HEIGHT) {
                    // Out of bounds
                    clearInterval(moveAttack);
                    attackEffect.remove();
                    aiState.isAttacking = false; // Reset attacking flag
                }
            }, 16);
        }

        // Add AI blink function
        function aiBlinkSkill() {
            if (entityStatus.ai.isFrozen) return;
            
            // Create afterimage effect
            const afterimage = document.createElement('div');
            afterimage.style.position = 'absolute';
            afterimage.style.width = `${CHARACTER_SIZE}px`;
            afterimage.style.height = `${CHARACTER_SIZE}px`;
            afterimage.style.background = 'rgba(128, 0, 128, 0.3)';
            afterimage.style.borderRadius = '50%';
            afterimage.style.left = aiState.x + 'px';
            afterimage.style.top = aiState.y + 'px';
            afterimage.style.animation = 'fadeOut 0.5s forwards';
            document.getElementById('gameArea').appendChild(afterimage);

            // Get all projectiles in the game area
            const projectiles = Array.from(document.querySelectorAll('#rangedBall')).filter(p => p.style.display !== 'none');
            
            let newX, newY;
            
            if (projectiles.length > 0) {
                // Find the closest projectile
                const closestProjectile = projectiles.reduce((closest, current) => {
                    const currentDist = Math.sqrt(
                        Math.pow(parseInt(current.style.left) - aiState.x, 2) + 
                        Math.pow(parseInt(current.style.top) - aiState.y, 2)
                    );
                    const closestDist = closest ? Math.sqrt(
                        Math.pow(parseInt(closest.style.left) - aiState.x, 2) + 
                        Math.pow(parseInt(closest.style.top) - aiState.y, 2)
                    ) : Infinity;
                    
                    return currentDist < closestDist ? current : closest;
                }, null);
                
                if (closestProjectile) {
                    // Calculate projectile direction
                    const projX = parseInt(closestProjectile.style.left);
                    const projY = parseInt(closestProjectile.style.top);
                    const projAngle = Math.atan2(projY - aiState.y, projX - aiState.x);
                    
                    // Blink perpendicular to the projectile's path
                    const perpAngle = projAngle + (Math.PI / 2) * (Math.random() < 0.5 ? 1 : -1);
                    const blinkDistance = 150;
                    
                    // Calculate new position perpendicular to projectile
                    newX = Math.max(CHARACTER_SIZE, Math.min(GAME_WIDTH - CHARACTER_SIZE, aiState.x + Math.cos(perpAngle) * blinkDistance));
                    newY = Math.max(CHARACTER_SIZE, Math.min(GAME_HEIGHT - CHARACTER_SIZE, aiState.y + Math.sin(perpAngle) * blinkDistance));
                }
            }
            
            // If no projectiles or invalid position, use default random blink
            if (!newX || !newY) {
                let attempts = 0;
                do {
                    newX = Math.max(CHARACTER_SIZE, Math.min(GAME_WIDTH - CHARACTER_SIZE, aiState.x + (Math.random() - 0.5) * 300));
                    newY = Math.max(CHARACTER_SIZE, Math.min(GAME_HEIGHT - CHARACTER_SIZE, aiState.y + (Math.random() - 0.5) * 300));
                    attempts++;
                } while (attempts < 10 && Math.sqrt(Math.pow(newX - charX, 2) + Math.pow(newY - charY, 2)) < 100);
            }

            // Apply blink
            aiState.isBlinking = true;
            aiState.x = newX;
            aiState.y = newY;
            dummy.style.opacity = '0.3';
            dummy.style.filter = 'blur(4px) brightness(1.5)';
            dummy.style.transition = 'all 0.2s ease-out';

            // Show blink effect text
            const blinkText = document.createElement('div');
            blinkText.className = 'combat-text';
            blinkText.style.position = 'absolute';
            blinkText.style.left = (aiState.x + 25) + 'px';
            blinkText.style.top = (aiState.y - 40) + 'px';
            blinkText.style.color = '#9370DB';
            blinkText.style.fontSize = '20px';
            blinkText.style.fontWeight = 'bold';
            blinkText.textContent = '⚡ Blink!';
            document.getElementById('gameArea').appendChild(blinkText);
            setTimeout(() => blinkText.remove(), 1000);

            // Reset AI appearance after blink
            setTimeout(() => {
                dummy.style.opacity = '1';
                dummy.style.filter = 'none';
                dummy.style.transition = '';
                aiState.isBlinking = false;
            }, 200);
        }

        // Add AI update to game loop
        setInterval(updateAI, 16);

        // Add global variable for player state
        let isPlayerDead = false;

        // Add player freeze state
        let isPlayerFrozen = false;
        let basePlayerMoveSpeed = 5;
        let currentMoveSpeed = basePlayerMoveSpeed;

        // Add save/load system
        function toggleSaveLoadPanel() {
            const panel = document.getElementById('saveLoadPanel');
            if (panel.style.display === 'none' || !panel.style.display) {
                updateSaveSlots();
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        function updateSaveSlots() {
            const slotsContainer = document.getElementById('saveSlots');
            slotsContainer.innerHTML = '';

            // Create 5 save slots
            for (let i = 1; i <= 5; i++) {
                const slot = document.createElement('div');
                slot.className = 'save-slot';
                
                // Load saved data
                const savedData = localStorage.getItem(`skillSet_${i}`);
                const saveDate = localStorage.getItem(`skillSet_${i}_date`);
                
                // Create slot content
                const slotInfo = document.createElement('div');
                slotInfo.innerHTML = `Slot ${i}${savedData ? `<br><small>${saveDate}</small>` : '<br><small>Empty</small>'}`;
                
                // Create buttons
                const saveBtn = document.createElement('button');
                saveBtn.className = 'save';
                saveBtn.textContent = 'Save';
                saveBtn.onclick = () => saveSkills(i);
                
                const loadBtn = document.createElement('button');
                loadBtn.className = 'load';
                loadBtn.textContent = 'Load';
                loadBtn.disabled = !savedData;
                loadBtn.onclick = () => loadSkills(i);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete';
                deleteBtn.textContent = 'Delete';
                deleteBtn.disabled = !savedData;
                deleteBtn.onclick = () => deleteSkills(i);
                
                // Add buttons to slot
                slot.appendChild(slotInfo);
                slot.appendChild(saveBtn);
                slot.appendChild(loadBtn);
                slot.appendChild(deleteBtn);
                
                slotsContainer.appendChild(slot);
            }
        }

        function saveSkills(slotNumber) {
            const skillsToSave = skills.map(skill => ({
                name: skill.name,
                damage: skill.damage,
                element: skill.element,
                spCost: skill.spCost,
                cooldownMs: skill.cooldownMs,
                isDodgeSkill: skill.isDodgeSkill,
                powerLevel: skill.powerLevel,
                type: skill.type || (skill.element === 'neutral' ? 'ranged' : 'ranged'),
                loreDescript: skill.loreDescript
            }));

            const currentDate = new Date().toLocaleString();
            
            localStorage.setItem(`skillSet_${slotNumber}`, JSON.stringify(skillsToSave));
            localStorage.setItem(`skillSet_${slotNumber}_date`, currentDate);
            
            // Show success message
            const successText = document.createElement('div');
            successText.className = 'combat-text';
            successText.style.position = 'fixed';
            successText.style.left = '50%';
            successText.style.top = '20%';
            successText.style.transform = 'translate(-50%, -50%)';
            successText.style.color = '#4CAF50';
            successText.style.fontSize = '20px';
            successText.textContent = `Skills saved to Slot ${slotNumber}!`;
            document.body.appendChild(successText);
            setTimeout(() => successText.remove(), 2000);
            
            updateSaveSlots();
        }

        function loadSkills(slotNumber) {
            const savedSkills = localStorage.getItem(`skillSet_${slotNumber}`);
            if (!savedSkills) return;

            const skillsData = JSON.parse(savedSkills);
            skills = skillsData.map(skillData => {
                // Create a temporary full skillData object for description generation
                const fullSkillData = {
                    ...skillData,
                    type: skillData.type || (skillData.element === 'neutral' ? 'ranged' : 'ranged'),
                    color: elements[skillData.element].color,
                    hasStatusEffect: false,
                    isAoE: false,
                    utilityValue: skillData.isDodgeSkill ? 8 : 2
                };

                return {
                    name: skillData.name,
                    effect: createSkillEffect(
                        fullSkillData.type,
                        elements[skillData.element].color,
                        skillData.damage,
                        skillData.spCost,
                        skillData.element,
                        skillData.name,
                        skillData.isDodgeSkill,
                        skillData.cooldownMs
                    ),
                    description: generateTechnicalDescription(fullSkillData, skillData.isDodgeSkill),
                    originalDescription: skillData.originalDescription || skillData.description,
                    damage: skillData.damage,
                    element: skillData.element,
                    spCost: skillData.spCost,
                    cooldownMs: skillData.cooldownMs,
                    isDodgeSkill: skillData.isDodgeSkill,
                    powerLevel: skillData.powerLevel,
                    type: fullSkillData.type
                };
            });

            // Show success message
            const successText = document.createElement('div');
            successText.className = 'combat-text';
            successText.style.position = 'fixed';
            successText.style.left = '50%';
            successText.style.top = '20%';
            successText.style.transform = 'translate(-50%, -50%)';
            successText.style.color = '#2196F3';
            successText.style.fontSize = '20px';
            successText.textContent = `Skills loaded from Slot ${slotNumber}!`;
            document.body.appendChild(successText);
            setTimeout(() => successText.remove(), 2000);

            updateSkillList();
            toggleSaveLoadPanel();
        }

        function deleteSkills(slotNumber) {
            localStorage.removeItem(`skillSet_${slotNumber}`);
            localStorage.removeItem(`skillSet_${slotNumber}_date`);
            
            // Show success message
            const successText = document.createElement('div');
            successText.className = 'combat-text';
            successText.style.position = 'fixed';
            successText.style.left = '50%';
            successText.style.top = '20%';
            successText.style.transform = 'translate(-50%, -50%)';
            successText.style.color = '#f44336';
            successText.style.fontSize = '20px';
            successText.textContent = `Slot ${slotNumber} cleared!`;
            document.body.appendChild(successText);
            setTimeout(() => successText.remove(), 2000);
            
            updateSaveSlots();
        }
    </script>
</body>
</html>